<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ReflectionTools</name>
    </assembly>
    <members>
        <member name="T:DanielWillett.ReflectionTools.Accessor">
            <summary>
            Reflection utilities for accessing private or internal members.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Accessor.Active">
            <summary>
            Implementation of <see cref="T:DanielWillett.ReflectionTools.IAccessor"/> currently in use by all static/extension methods.
            </summary>
            <remarks>By assigning a value to this property, you transfer ownership of the object to this class, meaning it shouldn't be used or disposed outside this class at all.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Accessor.LogILTraceMessages">
            <summary>
            Should <see cref="P:DanielWillett.ReflectionTools.Accessor.Logger"/> log generated IL code (as debug messages)?
            </summary>
            <remarks>Returns <see langword="false"/> if <see cref="P:DanielWillett.ReflectionTools.Accessor.Logger"/> is <see langword="null"/>.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Accessor.LogDebugMessages">
            <summary>
            Should <see cref="P:DanielWillett.ReflectionTools.Accessor.Logger"/> log debug messages?
            </summary>
            <remarks>Returns <see langword="false"/> if <see cref="P:DanielWillett.ReflectionTools.Accessor.Logger"/> is <see langword="null"/>.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Accessor.LogInfoMessages">
            <summary>
            Should <see cref="P:DanielWillett.ReflectionTools.Accessor.Logger"/> log info messages?
            </summary>
            <remarks>Returns <see langword="false"/> if <see cref="P:DanielWillett.ReflectionTools.Accessor.Logger"/> is <see langword="null"/>.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Accessor.LogWarningMessages">
            <summary>
            Should <see cref="P:DanielWillett.ReflectionTools.Accessor.Logger"/> log warning messages?
            </summary>
            <remarks>Returns <see langword="false"/> if <see cref="P:DanielWillett.ReflectionTools.Accessor.Logger"/> is <see langword="null"/>.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Accessor.LogErrorMessages">
            <summary>
            Should <see cref="P:DanielWillett.ReflectionTools.Accessor.Logger"/> log error messages?
            </summary>
            <remarks>Returns <see langword="false"/> if <see cref="P:DanielWillett.ReflectionTools.Accessor.Logger"/> is <see langword="null"/>.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Accessor.Logger">
            <summary>
            Logging IO for all methods in this library.
            <para>Assigning a value to this will dispose the previous value if needed.</para>
            </summary>
            <remarks>Default value is an instance of <see cref="T:DanielWillett.ReflectionTools.ConsoleReflectionToolsLogger"/>, which outputs to <see cref="T:System.Console"/>.
            By assigning a value to this property, you transfer ownership of the object to this class, meaning it shouldn't be used or disposed outside this class at all.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Accessor.Formatter">
            <summary>
            Logging IO for all methods in this library for standard output.
            <para>Assigning a value to this will dispose the previous value if needed.</para>
            </summary>
            <remarks>Default value is an instance of <see cref="T:DanielWillett.ReflectionTools.ConsoleReflectionToolsLogger"/>, which outputs to <see cref="T:System.Console"/>.
            By assigning a value to this property, you transfer ownership of the object to this class, meaning it shouldn't be used or disposed outside this class at all.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Accessor.ExceptionFormatter">
            <summary>
            Logging IO for all methods in this library for exceptions.
            <para>Assigning a value to this will dispose the previous value if needed.</para>
            </summary>
            <remarks>Default value is an instance of <see cref="T:DanielWillett.ReflectionTools.ConsoleReflectionToolsLogger"/>, which outputs to <see cref="T:System.Console"/>.
            By assigning a value to this property, you transfer ownership of the object to this class, meaning it shouldn't be used or disposed outside this class at all.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Accessor.MSCoreLib">
            <summary>
            System primary assembly.
            </summary>
            <remarks>Lazily cached.</remarks>
            <exception cref="T:System.TypeLoadException"/>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Accessor.IsMono">
            <summary>
            Whether or not the <c>Mono.Runtime</c> class is available. Indicates if the current runtime is Mono.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GenerateInstanceSetter``2(System.String,System.Boolean)">
            <summary>
            Generates a dynamic method that sets an instance field value. For value types use <see cref="M:DanielWillett.ReflectionTools.Accessor.GenerateInstanceSetter``1(System.Type,System.String,System.Boolean)"/> instead.
            </summary>
            <typeparam name="TInstance">Declaring type of the field.</typeparam>
            <typeparam name="TValue">Field return type.</typeparam>
            <param name="fieldName">Name of field that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GenerateInstanceSetter``2(System.Reflection.FieldInfo,System.Boolean)">
            <summary>
            Generates a dynamic method that sets an instance field value. For value types use <see cref="M:DanielWillett.ReflectionTools.Accessor.GenerateInstanceSetter``1(System.Reflection.FieldInfo,System.Boolean)"/> instead.
            </summary>
            <typeparam name="TInstance">Declaring type of the field.</typeparam>
            <typeparam name="TValue">Field return type.</typeparam>
            <param name="field">Field that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GenerateInstanceSetter(System.Reflection.FieldInfo,System.Boolean)">
            <summary>
            Generates a dynamic method that sets an instance field value.
            </summary>
            <param name="field">Field that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
            <returns>A delegate of type <see cref="T:DanielWillett.ReflectionTools.InstanceSetter`2"/> with the generic arguments being the same as how they were defined in the field. If <paramref name="field"/>'s declaring type is a value type, <c>TInstance</c> will be <see cref="T:System.Object"/> instead of the declaring type to allow setting of value type fields via boxing.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GenerateInstanceGetter``2(System.String,System.Boolean)">
            <summary>
            Generates a dynamic method that gets an instance field value. Works for reference or value types.
            </summary>
            <typeparam name="TInstance">Declaring type of the field.</typeparam>
            <typeparam name="TValue">Field return type.</typeparam>
            <param name="fieldName">Name of field that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GenerateInstanceGetter``2(System.Reflection.FieldInfo,System.Boolean)">
            <summary>
            Generates a dynamic method that gets an instance field value. Works for reference or value types.
            </summary>
            <typeparam name="TInstance">Declaring type of the field.</typeparam>
            <typeparam name="TValue">Field return type.</typeparam>
            <param name="field">Field that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GenerateInstanceGetter(System.Reflection.FieldInfo,System.Boolean)">
            <summary>
            Generates a dynamic method that gets an instance field value. Works for reference or value types.
            </summary>
            <param name="field">Field that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <returns>A delegate of type <see cref="T:DanielWillett.ReflectionTools.InstanceGetter`2"/> with the generic arguments being the same as how they were defined in the field.</returns>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GenerateInstanceSetter``1(System.Type,System.String,System.Boolean)">
            <summary>
            Generates a dynamic method that sets an instance field value.
            When using value types, you have to store the value type in a boxed variable before passing it. This allows you to pass it as a reference type.<br/><br/>
            <code>
            object instance = new CustomStruct();
            SetField.Invoke(instance, 3);
            CustomStruct result = (CustomStruct)instance;
            </code>
            </summary>
            <param name="declaringType">Declaring type of the field.</param>
            <typeparam name="TValue">Field return type.</typeparam>
            <param name="fieldName">Name of field that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GenerateInstanceSetter``1(System.Reflection.FieldInfo,System.Boolean)">
            <summary>
            Generates a dynamic method that sets an instance field value.
            When using value types, you have to store the value type in a boxed variable before passing it. This allows you to pass it as a reference type.<br/><br/>
            <code>
            object instance = new CustomStruct();
            SetField.Invoke(instance, 3);
            CustomStruct result = (CustomStruct)instance;
            </code>
            </summary>
            <typeparam name="TValue">Field return type.</typeparam>
            <param name="field">Field that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GenerateInstanceGetter``1(System.Type,System.String,System.Boolean)">
            <summary>
            Generates a dynamic method that gets an instance field value. Works for reference or value types.
            </summary>
            <param name="declaringType">Declaring type of the field.</param>
            <typeparam name="TValue">Field return type.</typeparam>
            <param name="fieldName">Name of field that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GenerateInstanceGetter``1(System.Reflection.FieldInfo,System.Boolean)">
            <summary>
            Generates a dynamic method that gets an instance field value. Works for reference or value types.
            </summary>
            <typeparam name="TValue">Field return type.</typeparam>
            <param name="field">Field that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GenerateInstancePropertySetter``2(System.String,System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate that sets an instance property value. For value types use <see cref="M:DanielWillett.ReflectionTools.Accessor.GenerateInstancePropertySetter``1(System.Type,System.String,System.Boolean,System.Boolean)"/> instead.
            </summary>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).
            This also must be <see langword="true"/> to not null-check instance methods of parameter-less reference types with a dynamic method.</param>
            <typeparam name="TInstance">Declaring type of the property.</typeparam>
            <typeparam name="TValue">Property return type.</typeparam>
            <param name="propertyName">Name of property that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GenerateInstancePropertyGetter``2(System.String,System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate that gets an instance property value. Works for reference or value types.
            </summary>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).
            This also must be <see langword="true"/> to not null-check instance methods of parameter-less reference types with a dynamic method.</param>
            <typeparam name="TInstance">Declaring type of the property.</typeparam>
            <typeparam name="TValue">Property return type.</typeparam>
            <param name="propertyName">Name of property that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GenerateInstancePropertySetter``2(System.Reflection.PropertyInfo,System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate that sets an instance property value. For value types use <see cref="M:DanielWillett.ReflectionTools.Accessor.GenerateInstancePropertySetter``1(System.Reflection.PropertyInfo,System.Boolean,System.Boolean)"/> instead.
            </summary>
            <typeparam name="TInstance">Declaring type of the property.</typeparam>
            <typeparam name="TValue">Property return type.</typeparam>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).
            This also must be <see langword="true"/> to not null-check instance methods of parameter-less reference types with a dynamic method.</param>
            <param name="property">Property that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GenerateInstancePropertyGetter``2(System.Reflection.PropertyInfo,System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate that gets an instance property value. Works for reference or value types.
            </summary>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).
            This also must be <see langword="true"/> to not null-check instance methods of parameter-less reference types with a dynamic method.</param>
            <typeparam name="TInstance">Declaring type of the property.</typeparam>
            <typeparam name="TValue">Property return type.</typeparam>
            <param name="property">Property that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GenerateInstancePropertySetter(System.Reflection.PropertyInfo,System.Boolean)">
            <summary>
            Generates a delegate that sets an instance property value.
            </summary>
            <param name="property">Property that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <returns>A delegate of type <see cref="T:DanielWillett.ReflectionTools.InstanceSetter`2"/> with the generic arguments being the same as how they were defined in the field. If <paramref name="property"/>'s declaring type is a value type, <c>TInstance</c> will be <see cref="T:System.Object"/> instead of the declaring type to allow setting of value type fields via boxing.</returns>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GenerateInstancePropertyGetter(System.Reflection.PropertyInfo,System.Boolean)">
            <summary>
            Generates a delegate that gets an instance property value. Works for reference or value types.
            </summary>
            <param name="property">Property that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <returns>A delegate of type <see cref="T:DanielWillett.ReflectionTools.InstanceGetter`2"/> with the generic arguments being the same as how they were defined in the property.</returns>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GenerateInstancePropertySetter``1(System.Type,System.String,System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate if possible, otherwise a dynamic method, that sets an instance property value.
            When using value types, you have to store the value type in a boxed variable before passing it. This allows you to pass it as a reference type.<br/><br/>
            <code>
            object instance = new CustomStruct();
            SetProperty.Invoke(instance, 3);
            CustomStruct result = (CustomStruct)instance;
            </code>
            </summary>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).
            This also must be <see langword="true"/> to not null-check instance methods of parameter-less reference types with a dynamic method.</param>
            <param name="declaringType">Declaring type of the property.</param>
            <typeparam name="TValue">Property return type.</typeparam>
            <param name="propertyName">Name of property that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GenerateInstancePropertyGetter``1(System.Type,System.String,System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate if possible, otherwise a dynamic method, that gets an instance property value. Works for reference or value types.
            </summary>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).
            This also must be <see langword="true"/> to not null-check instance methods of parameter-less reference types with a dynamic method.</param>
            <param name="declaringType">Declaring type of the property.</param>
            <typeparam name="TValue">Property return type.</typeparam>
            <param name="propertyName">Name of property that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GenerateInstancePropertySetter``1(System.Reflection.PropertyInfo,System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate if possible, otherwise a dynamic method, that sets an instance property value.
            When using value types, you have to store the value type in a boxed variable before passing it. This allows you to pass it as a reference type.<br/><br/>
            <code>
            object instance = new CustomStruct();
            SetProperty.Invoke(instance, 3);
            CustomStruct result = (CustomStruct)instance;
            </code>
            </summary>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).
            This also must be <see langword="true"/> to not null-check instance methods of parameter-less reference types with a dynamic method.</param>
            <typeparam name="TValue">Property return type.</typeparam>
            <param name="property">Property that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GenerateInstancePropertyGetter``1(System.Reflection.PropertyInfo,System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate if possible, otherwise a dynamic method, that gets an instance property value. Works for reference or value types.
            </summary>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).
            This also must be <see langword="true"/> to not null-check instance methods of parameter-less reference types with a dynamic method.</param>
            <typeparam name="TValue">Property return type.</typeparam>
            <param name="property">Property that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GenerateStaticSetter``2(System.String,System.Boolean)">
            <summary>
            Generates a dynamic method that sets a static field value.
            </summary>
            <typeparam name="TDeclaringType">Declaring type of the field.</typeparam>
            <typeparam name="TValue">Field return type.</typeparam>
            <param name="fieldName">Name of the field that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GenerateStaticGetter``2(System.String,System.Boolean)">
            <summary>
            Generates a dynamic method that gets a static field value.
            </summary>
            <typeparam name="TDeclaringType">Declaring type of the field.</typeparam>
            <typeparam name="TValue">Field return type.</typeparam>
            <param name="fieldName">Name of the field that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GenerateStaticSetter``1(System.Type,System.String,System.Boolean)">
            <summary>
            Generates a dynamic method that sets a static field value.
            </summary>
            <param name="declaringType">Declaring type of the field.</param>
            <typeparam name="TValue">Field return type.</typeparam>
            <param name="fieldName">Name of the field that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GenerateStaticSetter``1(System.Reflection.FieldInfo,System.Boolean)">
            <summary>
            Generates a dynamic method that sets a static field value.
            </summary>
            <typeparam name="TValue">Field return type.</typeparam>
            <param name="field">Field that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GenerateStaticGetter``1(System.Type,System.String,System.Boolean)">
            <summary>
            Generates a dynamic method that gets a static field value.
            </summary>
            <param name="declaringType">Declaring type of the field.</param>
            <typeparam name="TValue">Field return type.</typeparam>
            <param name="fieldName">Name of the field that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GenerateStaticSetter(System.Reflection.FieldInfo,System.Boolean)">
            <summary>
            Generates a dynamic method that sets a static field value.
            </summary>
            <param name="field">Field that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <returns>A delegate of type <see cref="T:DanielWillett.ReflectionTools.StaticSetter`1"/> with the generic argument being the type of the field.</returns>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GenerateStaticGetter``1(System.Reflection.FieldInfo,System.Boolean)">
            <summary>
            Generates a dynamic method that gets a static field value.
            </summary>
            <typeparam name="TValue">Field return type.</typeparam>
            <param name="field">Field that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GenerateStaticGetter(System.Reflection.FieldInfo,System.Boolean)">
            <summary>
            Generates a dynamic method that gets a static field value.
            </summary>
            <param name="field">Field that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <returns>A delegate of type <see cref="T:DanielWillett.ReflectionTools.StaticGetter`1"/> with the generic argument being the type of the field.</returns>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GenerateStaticPropertySetter``2(System.String,System.Boolean)">
            <summary>
            Generates a delegate or dynamic method that sets a static property value.
            </summary>
            <typeparam name="TDeclaringType">Declaring type of the property.</typeparam>
            <typeparam name="TValue">Property return type.</typeparam>
            <param name="propertyName">Name of property that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GenerateStaticPropertySetter``2(System.String,System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate or dynamic method that sets a static property value.
            </summary>
            <typeparam name="TDeclaringType">Declaring type of the property.</typeparam>
            <typeparam name="TValue">Property return type.</typeparam>
            <param name="propertyName">Name of property that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).
            This also must be <see langword="true"/> to not null-check instance methods of parameter-less reference types with a dynamic method.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GenerateStaticPropertyGetter``2(System.String,System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate that gets a static property value.
            </summary>
            <typeparam name="TDeclaringType">Declaring type of the property.</typeparam>
            <typeparam name="TValue">Property return type.</typeparam>
            <param name="propertyName">Name of property that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).
            This also must be <see langword="true"/> to not null-check instance methods of parameter-less reference types with a dynamic method.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GenerateStaticPropertySetter``1(System.Type,System.String,System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate or dynamic method that sets a static property value.
            </summary>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).
            This also must be <see langword="true"/> to not null-check instance methods of parameter-less reference types with a dynamic method.</param>
            <param name="declaringType">Declaring type of the property.</param>
            <typeparam name="TValue">Property return type.</typeparam>
            <param name="propertyName">Name of property that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GenerateStaticPropertyGetter``1(System.Type,System.String,System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate that gets a static property value.
            </summary>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).
            This also must be <see langword="true"/> to not null-check instance methods of parameter-less reference types with a dynamic method.</param>
            <param name="declaringType">Declaring type of the property.</param>
            <typeparam name="TValue">Property return type.</typeparam>
            <param name="propertyName">Name of property that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GenerateStaticPropertySetter``1(System.Reflection.PropertyInfo,System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate or dynamic method that sets a static property value.
            </summary>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).
            This also must be <see langword="true"/> to not null-check instance methods of parameter-less reference types with a dynamic method.</param>
            <typeparam name="TValue">Property return type.</typeparam>
            <param name="property">Property that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GenerateStaticPropertyGetter``1(System.Reflection.PropertyInfo,System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate that gets a static property value.
            </summary>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).
            This also must be <see langword="true"/> to not null-check instance methods of parameter-less reference types with a dynamic method.</param>
            <typeparam name="TValue">Property return type.</typeparam>
            <param name="property">Property that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GenerateStaticPropertySetter(System.Reflection.PropertyInfo,System.Boolean)">
            <summary>
            Generates a delegate or dynamic method that sets a static property value.
            </summary>
            <param name="property">Property that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <returns>A delegate of type <see cref="T:DanielWillett.ReflectionTools.StaticSetter`1"/> with the generic argument being the type of the property.</returns>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GenerateStaticPropertyGetter(System.Reflection.PropertyInfo,System.Boolean)">
            <summary>
            Generates a delegate that gets a static property value.
            </summary>
            <param name="property">Property that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <returns>A delegate of type <see cref="T:DanielWillett.ReflectionTools.StaticGetter`1"/> with the generic argument being the type of the property.</returns>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GenerateInstanceCaller``1(System.String,System.Type[],System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate or dynamic method that calls an instance method. For non-readonly methods with value types, the instance must be boxed (passed as <see cref="T:System.Object"/>) to keep any changes made.
            </summary>
            <remarks>The first parameter will be the instance.</remarks>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).
            This also must be <see langword="true"/> to not null-check instance methods of parameter-less reference types with a dynamic method.</param>
            <returns>A delegate of type <see cref="T:System.Action"/> or <see cref="T:System.Func`1"/> (or one of their generic counterparts), depending on the method signature. The first parameter will be the instance.</returns>
            <param name="methodName">Name of method that will be called.</param>
            <param name="parameters">Optional parameter list for resolving ambiguous methods.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GenerateInstanceCaller``2(System.String,System.Boolean,System.Boolean,System.Type[])">
            <summary>
            Generates a delegate or dynamic method that calls an instance method. For non-readonly methods with value types, the instance must be boxed (passed as <see cref="T:System.Object"/>) to keep any changes made.
            </summary>
            <remarks>The first parameter will be the instance.</remarks>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).
            This also must be <see langword="true"/> to not null-check instance methods of parameter-less reference types with a dynamic method.</param>
            <param name="methodName">Name of method that will be called.</param>
            <param name="parameters">Optional parameter list for resolving ambiguous methods.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GenerateInstanceCaller(System.Reflection.MethodInfo,System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate or dynamic method that calls an instance method. For non-readonly methods with value types, the instance must be boxed (passed as <see cref="T:System.Object"/>) to keep any changes made.
            </summary>
            <remarks>The first parameter will be the instance.</remarks>
            <returns>A delegate of type <see cref="T:System.Action"/> or <see cref="T:System.Func`1"/> (or one of their generic counterparts), depending on the method signature. The first parameter will be the instance.</returns>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).
            This also must be <see langword="true"/> to not null-check instance methods of parameter-less reference types with a dynamic method.</param>
            <param name="method">Method that will be called.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GenerateInstanceCaller``1(System.Reflection.MethodInfo,System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate or dynamic method that calls an instance method. For non-readonly methods with value types, the instance must be boxed (passed as <see cref="T:System.Object"/>) to keep any changes made.
            </summary>
            <remarks>The first parameter will be the instance.</remarks>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).
            This also must be <see langword="true"/> to not null-check instance methods of parameter-less reference types with a dynamic method.</param>
            <param name="method">Method that will be called.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GenerateInstanceCaller(System.Type,System.Reflection.MethodInfo,System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate or dynamic method that calls an instance method. For non-readonly methods with value types, the instance must be boxed (passed as <see cref="T:System.Object"/>) to keep any changes made.
            </summary>
            <remarks>The first parameter will be the instance.</remarks>
            <param name="delegateType">Type of delegate to return.</param>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).
            This also must be <see langword="true"/> to not null-check instance methods of parameter-less reference types with a dynamic method.</param>
            <param name="method">Method that will be called.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GenerateStaticCaller``1(System.String,System.Type[],System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate or dynamic method that calls a static method.
            </summary>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).</param>
            <returns>A delegate of type <see cref="T:System.Action"/> or <see cref="T:System.Func`1"/> (or one of their generic counterparts), depending on the method signature.</returns>
            <param name="methodName">Name of method that will be called.</param>
            <param name="parameters">Optional parameter list for resolving ambiguous methods.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GenerateStaticCaller``2(System.String,System.Boolean,System.Boolean,System.Type[])">
            <summary>
            Generates a delegate or dynamic method that calls a static method.
            </summary>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).</param>
            <param name="methodName">Name of method that will be called.</param>
            <param name="parameters">Optional parameter list for resolving ambiguous methods.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GenerateStaticCaller(System.Reflection.MethodInfo,System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate or dynamic method that calls a static method.
            </summary>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).</param>
            <returns>A delegate of type <see cref="T:System.Action"/> or <see cref="T:System.Func`1"/> (or one of their generic counterparts), depending on the method signature.</returns>
            <param name="method">Method that will be called.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GenerateStaticCaller``1(System.Reflection.MethodInfo,System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate or dynamic method that calls a static method.
            </summary>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).</param>
            <param name="method">Method that will be called.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GenerateStaticCaller(System.Type,System.Reflection.MethodInfo,System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate or dynamic method that calls a static method.
            </summary>
            <param name="delegateType">Type of delegate to return.</param>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).</param>
            <param name="method">Method that will be called.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GetDynamicMethodFlags(System.Boolean,System.Reflection.MethodAttributes@,System.Reflection.CallingConventions@)">
            <summary>
            Gets platform-specific flags for creating dynamic methods.
            </summary>
            <param name="static">Whether or not the method has no 'instance', only considered when on mono.</param>
            <param name="attributes">Method attributes to pass to <see cref="T:System.Reflection.Emit.DynamicMethod"/> constructor.</param>
            <param name="convention">Method convention to pass to <see cref="T:System.Reflection.Emit.DynamicMethod"/> constructor.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GetVisibility(System.Type)">
            <summary>
            Gets a simplified enum representing the visiblity (accessibility) of a <paramref name="type"/>.
            </summary>
            <remarks>Takes nested types into account, returning the lowest visibility in the nested hierarchy
            (ex. if an internal class is nested in a private nested type, this method will consider it private).</remarks>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GetVisibility(System.Reflection.MethodBase)">
            <summary>
            Gets a simplified enum representing the visiblity (accessibility) of a <paramref name="method"/>.
            </summary>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GetVisibility(System.Reflection.FieldInfo)">
            <summary>
            Gets a simplified enum representing the visiblity (accessibility) of a <paramref name="field"/>.
            </summary>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GetVisibility(System.Reflection.PropertyInfo)">
            <summary>
            Gets a simplified enum representing the visiblity (accessibility) of a <paramref name="property"/>.
            </summary>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GetVisibility(System.Reflection.EventInfo)">
            <summary>
            Gets a simplified enum representing the visiblity (accessibility) of an <paramref name="event"/>.
            </summary>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GetHighestVisibility(System.Reflection.MethodBase,System.Reflection.MethodBase)">
            <summary>
            Get the highest visibilty needed for both of the given methods to be visible. Methods which are <see langword="null"/> are ignored.
            </summary>
            <remarks>Useful for getting property visiblity manually, will always be at least <see cref="F:DanielWillett.ReflectionTools.MemberVisibility.Private"/>.</remarks>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GetHighestVisibility(System.Reflection.MethodBase,System.Reflection.MethodBase,System.Reflection.MethodBase)">
            <summary>
            Get the highest visibilty needed for all three of the given methods to be visible. Methods which are <see langword="null"/> are ignored.
            </summary>
            <remarks>Useful for getting event visiblity manually, will always be at least <see cref="F:DanielWillett.ReflectionTools.MemberVisibility.Private"/>.</remarks>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GetHighestVisibility(System.Reflection.MethodBase[])">
            <summary>
            Get the highest visibilty needed for all of the given methods to be visible. Methods which are <see langword="null"/> are ignored.
            </summary>
            <remarks>Will always be at least <see cref="F:DanielWillett.ReflectionTools.MemberVisibility.Private"/>.</remarks>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.AssemblyGivesInternalAccess(System.Reflection.Assembly,System.String)">
            <summary>
            Checks if <paramref name="assembly"/> has a <see cref="T:System.Runtime.CompilerServices.InternalsVisibleToAttribute"/> with the given <paramref name="assemblyName"/>.
            The value of the attribute must match <paramref name="assemblyName"/> exactly.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.IsExtern(System.Reflection.MethodBase)">
            <summary>
            Checks <paramref name="method"/> for the <see langword="extern"/> flag.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.IsExtern(System.Reflection.FieldInfo)">
            <summary>
            Checks <paramref name="field"/> for the <see langword="extern"/> flag.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.IsExtern(System.Reflection.PropertyInfo,System.Boolean)">
            <summary>
            Checks <paramref name="property"/>'s getter and setter for the <see langword="extern"/> flag.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.IsDefinedSafe``1(System.Reflection.ICustomAttributeProvider,System.Boolean)">
            <summary>
            Checks for the the attribute of type <typeparamref name="TAttribute"/> on <paramref name="member"/>.
            </summary>
            <remarks>Alias of <see cref="M:DanielWillett.ReflectionTools.Accessor.HasAttributeSafe``1(System.Reflection.ICustomAttributeProvider,System.Boolean)"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.IsDefinedSafe(System.Reflection.ICustomAttributeProvider,System.Type,System.Boolean)">
            <summary>
            Checks for the attribute of type <paramref name="attributeType"/> on <paramref name="member"/>.
            </summary>
            <remarks>Alias of <see cref="M:DanielWillett.ReflectionTools.Accessor.HasAttributeSafe(System.Reflection.ICustomAttributeProvider,System.Type,System.Boolean)"/>.</remarks>
            <param name="member">Member to check for attributes. This can be <see cref="T:System.Reflection.Module"/>, <see cref="T:System.Reflection.Assembly"/>, <see cref="T:System.Reflection.MemberInfo"/>, or <see cref="T:System.Reflection.ParameterInfo"/>.</param>
            <param name="attributeType">Type of the attribute to check for.</param>
            <param name="inherit">Also check parent members.</param>
            <exception cref="T:System.ArgumentException"><paramref name="attributeType"/> did not derive from <see cref="T:System.Attribute"/>.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.IsCompilerAttributeDefinedSafe(System.Reflection.ICustomAttributeProvider,System.String,System.Boolean)">
            <summary>
            Checks for the attribute of type <c>System.Runtime.CompilerServices.<paramref name="typeName"/></c> on <paramref name="member"/>.
            </summary>
            <remarks>Alias of <see cref="M:DanielWillett.ReflectionTools.Accessor.HasCompilerAttributeSafe(System.Reflection.ICustomAttributeProvider,System.String,System.Boolean)"/>. In some older versions of .NET Framework, attributes not available in the API at that version will be added to the assembly on compile. This checks for those.</remarks>
            <param name="member">Member to check for attributes. This can be <see cref="T:System.Reflection.Module"/>, <see cref="T:System.Reflection.Assembly"/>, <see cref="T:System.Reflection.MemberInfo"/>, or <see cref="T:System.Reflection.ParameterInfo"/>.</param>
            <param name="typeName">Type name of the attribute in <c>System.Runtime.CompilerServices</c> to check for.</param>
            <param name="inherit">Also check parent members.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.HasAttributeSafe``1(System.Reflection.ICustomAttributeProvider,System.Boolean)">
            <summary>
            Checks for the the attribute of type <typeparamref name="TAttribute"/> on <paramref name="member"/>.
            </summary>
            <remarks>Alias of <see cref="M:DanielWillett.ReflectionTools.Accessor.IsDefinedSafe``1(System.Reflection.ICustomAttributeProvider,System.Boolean)"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.HasAttributeSafe(System.Reflection.ICustomAttributeProvider,System.Type,System.Boolean)">
            <summary>
            Checks for the attribute of type <paramref name="attributeType"/> on <paramref name="member"/>.
            </summary>
            <remarks>Alias of <see cref="M:DanielWillett.ReflectionTools.Accessor.IsDefinedSafe(System.Reflection.ICustomAttributeProvider,System.Type,System.Boolean)"/>.</remarks>
            <param name="member">Member to check for attributes. This can be <see cref="T:System.Reflection.Module"/>, <see cref="T:System.Reflection.Assembly"/>, <see cref="T:System.Reflection.MemberInfo"/>, or <see cref="T:System.Reflection.ParameterInfo"/>.</param>
            <param name="attributeType">Type of the attribute to check for.</param>
            <param name="inherit">Also check parent members.</param>
            <exception cref="T:System.ArgumentException"><paramref name="attributeType"/> did not derive from <see cref="T:System.Attribute"/>.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.HasCompilerAttributeSafe(System.Reflection.ICustomAttributeProvider,System.String,System.Boolean)">
            <summary>
            Checks for the attribute of type <c>System.Runtime.CompilerServices.<paramref name="typeName"/></c> on <paramref name="member"/>.
            </summary>
            <remarks>Alias of <see cref="M:DanielWillett.ReflectionTools.Accessor.IsCompilerAttributeDefinedSafe(System.Reflection.ICustomAttributeProvider,System.String,System.Boolean)"/>. In some older versions of .NET Framework, attributes not available in the API at that version will be added to the assembly on compile. This checks for those.</remarks>
            <param name="member">Member to check for attributes. This can be <see cref="T:System.Reflection.Module"/>, <see cref="T:System.Reflection.Assembly"/>, <see cref="T:System.Reflection.MemberInfo"/>, or <see cref="T:System.Reflection.ParameterInfo"/>.</param>
            <param name="typeName">Type name of the attribute in <c>System.Runtime.CompilerServices</c> to check for.</param>
            <param name="inherit">Also check parent members.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GetAttributeSafe``1(System.Reflection.ICustomAttributeProvider,System.Boolean)">
            <summary>
            Checks for and returns the the attribute of type <typeparamref name="TAttribute"/> on <paramref name="member"/>.
            </summary>
            <param name="inherit">Also check parent members.</param>
            <param name="member">Member to check for attributes. This can be <see cref="T:System.Reflection.Module"/>, <see cref="T:System.Reflection.Assembly"/>, <see cref="T:System.Reflection.MemberInfo"/>, or <see cref="T:System.Reflection.ParameterInfo"/>.</param>
            <typeparam name="TAttribute">Type of the attribute to check for.</typeparam>
            <exception cref="T:System.Reflection.AmbiguousMatchException">There are more than one attributes of type <typeparamref name="TAttribute"/>.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GetAttributeSafe(System.Reflection.ICustomAttributeProvider,System.Type,System.Boolean)">
            <summary>
            Checks for and returns the attribute of type <paramref name="attributeType"/> on <paramref name="member"/>.
            </summary>
            <param name="member">Member to check for attributes. This can be <see cref="T:System.Reflection.Module"/>, <see cref="T:System.Reflection.Assembly"/>, <see cref="T:System.Reflection.MemberInfo"/>, or <see cref="T:System.Reflection.ParameterInfo"/>.</param>
            <param name="attributeType">Type of the attribute to check for.</param>
            <param name="inherit">Also check parent members.</param>
            <exception cref="T:System.ArgumentException"><paramref name="attributeType"/> did not derive from <see cref="T:System.Attribute"/>.</exception>
            <exception cref="T:System.Reflection.AmbiguousMatchException">There are more than one attributes of type <paramref name="attributeType"/>.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GetAttributesSafe``1(System.Reflection.ICustomAttributeProvider,System.Boolean)">
            <summary>
            Checks for and returns the the attribute of type <typeparamref name="TAttribute"/> on <paramref name="member"/>.
            </summary>
            <param name="inherit">Also check parent members.</param>
            <param name="member">Member to check for attributes. This can be <see cref="T:System.Reflection.Module"/>, <see cref="T:System.Reflection.Assembly"/>, <see cref="T:System.Reflection.MemberInfo"/>, or <see cref="T:System.Reflection.ParameterInfo"/>.</param>
            <typeparam name="TAttribute">Type of the attribute to check for.</typeparam>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GetAttributesSafe(System.Reflection.ICustomAttributeProvider,System.Type,System.Boolean)">
            <summary>
            Checks for and returns the attribute of type <paramref name="attributeType"/> on <paramref name="member"/>.
            </summary>
            <param name="member">Member to check for attributes. This can be <see cref="T:System.Reflection.Module"/>, <see cref="T:System.Reflection.Assembly"/>, <see cref="T:System.Reflection.MemberInfo"/>, or <see cref="T:System.Reflection.ParameterInfo"/>.</param>
            <param name="attributeType">Type of the attribute to check for.</param>
            <param name="inherit">Also check parent members.</param>
            <exception cref="T:System.ArgumentException"><paramref name="attributeType"/> did not derive from <see cref="T:System.Attribute"/>.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.TryGetAttributeSafe``1(System.Reflection.ICustomAttributeProvider,``0@,System.Boolean)">
            <summary>
            Checks for and outputs the the attribute of type <typeparamref name="TAttribute"/> on <paramref name="member"/>.
            </summary>
            <param name="attribute">Found attribute, or <see langword="null"/> if it's not found (the function will return <see langword="false"/>).</param>
            <param name="inherit">Also check parent members.</param>
            <param name="member">Member to check for attributes. This can be <see cref="T:System.Reflection.Module"/>, <see cref="T:System.Reflection.Assembly"/>, <see cref="T:System.Reflection.MemberInfo"/>, or <see cref="T:System.Reflection.ParameterInfo"/>.</param>
            <typeparam name="TAttribute">Type of the attribute to check for.</typeparam>
            <returns><see langword="true"/> if the attribute was found, otherwise <see langword="false"/>.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.IsReadOnly(System.Reflection.ICustomAttributeProvider)">
            <summary>
            Checks for the <see cref="T:System.Runtime.CompilerServices.IsReadOnlyAttribute"/> on <paramref name="member"/>, which signifies the readonly value.
            <remarks>This behavior is overridden on fields to check <see cref="P:System.Reflection.FieldInfo.IsInitOnly"/>.</remarks>
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.IsByRefLikeType(System.Type)">
            <summary>
            Checks for the <see cref="T:System.Runtime.CompilerServices.IsByRefLikeAttribute"/> on <paramref name="type"/>, or <see cref="P:System.Type.IsByRefLike"/> on newer platforms.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.IsIgnored(System.Type)">
            <summary>
            Checks for the <see cref="T:DanielWillett.ReflectionTools.IgnoreAttribute"/> on <paramref name="type"/>.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.IsIgnored(System.Reflection.MemberInfo)">
            <summary>
            Checks for the <see cref="T:DanielWillett.ReflectionTools.IgnoreAttribute"/> on <paramref name="member"/>.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.IsIgnored(System.Reflection.Assembly)">
            <summary>
            Checks for the <see cref="T:DanielWillett.ReflectionTools.IgnoreAttribute"/> on <paramref name="assembly"/>.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.IsIgnored(System.Reflection.ParameterInfo)">
            <summary>
            Checks for the <see cref="T:DanielWillett.ReflectionTools.IgnoreAttribute"/> on <paramref name="parameter"/>.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.IsIgnored(System.Reflection.Module)">
            <summary>
            Checks for the <see cref="T:DanielWillett.ReflectionTools.IgnoreAttribute"/> on <paramref name="module"/>.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GetPriority(System.Type)">
            <summary>
            Checks for the <see cref="T:DanielWillett.ReflectionTools.PriorityAttribute"/> on <paramref name="type"/> and returns the priority (or zero if not found).
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GetPriority(System.Reflection.MemberInfo)">
            <summary>
            Checks for the <see cref="T:DanielWillett.ReflectionTools.PriorityAttribute"/> on <paramref name="member"/> and returns the priority (or zero if not found).
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GetPriority(System.Reflection.Assembly)">
            <summary>
            Checks for the <see cref="T:DanielWillett.ReflectionTools.PriorityAttribute"/> on <paramref name="assembly"/> and returns the priority (or zero if not found).
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GetPriority(System.Reflection.ParameterInfo)">
            <summary>
            Checks for the <see cref="T:DanielWillett.ReflectionTools.PriorityAttribute"/> on <paramref name="parameter"/> and returns the priority (or zero if not found).
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GetPriority(System.Reflection.Module)">
            <summary>
            Checks for the <see cref="T:DanielWillett.ReflectionTools.PriorityAttribute"/> on <paramref name="module"/> and returns the priority (or zero if not found).
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GetMethod(System.Delegate)">
            <summary>
            Safely gets the reflection method info of the passed method. Works best with static methods.<br/><br/>
            <code>
            MethodInfo? method = Accessor.GetMethod(Guid.Parse);
            </code>
            </summary>
            <returns>A method info of a passed delegate</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GetDefaultDelegate(System.Type,System.Collections.Generic.IList{System.Reflection.ParameterInfo},System.Type)">
            <param name="returnType">Return type of the method.</param>
            <param name="parameters">Method parameters, not including the instance.</param>
            <param name="instanceType">The declaring type, or <see langword="null"/> for static methods.</param>
            <remarks>The first argument will be the instance.</remarks>
            <returns>A delegate of type <see cref="T:System.Action"/> or <see cref="T:System.Func`1"/> (or one of their generic counterparts), depending on the method signature, or <see langword="null"/> if there are too many parameters.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.ForEachBaseType(System.Type,DanielWillett.ReflectionTools.ForEachBaseType,System.Boolean,System.Boolean)">
            <summary>
            Used to perform a repeated <paramref name="action"/> for each base type of a <paramref name="type"/>.
            </summary>
            <param name="type">Highest (most derived) type in the hierarchy.</param>
            <param name="action">Called optionally for <paramref name="type"/>, then for each base type in order from most related to least related.</param>
            <param name="includeParent">Call <paramref name="action"/> on <paramref name="type"/>. Overrides <paramref name="excludeSystemBase"/>.</param>
            <param name="excludeSystemBase">Excludes calling <paramref name="action"/> for <see cref="T:System.Object"/> or <see cref="T:System.ValueType"/>.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.ForEachBaseType(System.Type,DanielWillett.ReflectionTools.ForEachBaseTypeWhile,System.Boolean,System.Boolean)">
            <summary>
            Used to perform a repeated <paramref name="action"/> for each base type of a <paramref name="type"/>.
            </summary>
            <remarks>Execution can be broken by returning <see langword="false"/>.</remarks>
            <param name="type">Highest (most derived) type in the hierarchy.</param>
            <param name="action">Called optionally for <paramref name="type"/>, then for each base type in order from most related to least related.</param>
            <param name="includeParent">Call <paramref name="action"/> on <paramref name="type"/>. Overrides <paramref name="excludeSystemBase"/>.</param>
            <param name="excludeSystemBase">Excludes calling <paramref name="action"/> for <see cref="T:System.Object"/> or <see cref="T:System.ValueType"/>.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GetTypesSafe(System.Boolean)">
            <returns>Every type defined in the calling assembly.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GetTypesSafe(System.Reflection.Assembly,System.Boolean)">
            <returns>Every type defined in <paramref name="assembly"/>.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GetTypesSafe(System.Collections.Generic.IEnumerable{System.Reflection.Assembly},System.Boolean)">
            <returns>Every type defined in the provided <paramref name="assmeblies"/>.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GetImplementedMethod(System.Type,System.Reflection.MethodInfo)">
            <summary>
            Takes a method declared in an interface and returns an implementation on <paramref name="type"/>. Useful for getting explicit implementations.
            </summary>
            <exception cref="T:System.ArgumentException"><paramref name="interfaceMethod"/> is not defined in an interface or <paramref name="type"/> does not implement the interface it's defined in.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GetDelegateSignature``1(System.Type@,System.Reflection.ParameterInfo[]@)">
            <summary>
            Gets the (cached) <paramref name="returnType"/> and <paramref name="parameters"/> of a <typeparamref name="TDelegate"/> delegate type.
            </summary>
            <exception cref="T:System.NotSupportedException">Reflection failure.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GetDelegateSignature``1(System.Reflection.ParameterInfo@,System.Reflection.ParameterInfo[]@)">
            <summary>
            Gets the (cached) <paramref name="returnParameter"/> and <paramref name="parameters"/> of a <typeparamref name="TDelegate"/> delegate type.
            </summary>
            <exception cref="T:System.NotSupportedException">Reflection failure.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GetReturnType``1">
            <summary>
            Gets the (cached) return type of a <typeparamref name="TDelegate"/> delegate type.
            </summary>
            <exception cref="T:System.NotSupportedException">Reflection failure.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GetReturnParameter``1">
            <summary>
            Gets the (cached) return parameter info of a <typeparamref name="TDelegate"/> delegate type.
            </summary>
            <exception cref="T:System.NotSupportedException">Reflection failure.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GetParameters``1">
            <summary>
            Gets the (cached) parameters of a <typeparamref name="TDelegate"/> delegate type.
            </summary>
            <exception cref="T:System.NotSupportedException">Reflection failure.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GetInvokeMethod``1">
            <summary>
            Gets the (cached) <see langword="Invoke"/> method of a <typeparamref name="TDelegate"/> delegate type. All delegates have one by default.
            </summary>
            <exception cref="T:System.NotSupportedException">Reflection failure.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GetDelegateSignature(System.Type,System.Type@,System.Reflection.ParameterInfo[]@)">
            <summary>
            Gets the <paramref name="returnType"/> and <paramref name="parameters"/> of a <paramref name="delegateType"/>.
            </summary>
            <exception cref="T:System.NotSupportedException">Reflection failure.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GetDelegateSignature(System.Type,System.Reflection.ParameterInfo@,System.Reflection.ParameterInfo[]@)">
            <summary>
            Gets the <paramref name="returnParameter"/> and <paramref name="parameters"/> of a <paramref name="delegateType"/>.
            </summary>
            <exception cref="T:System.NotSupportedException">Reflection failure.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GetReturnType(System.Type)">
            <summary>
            Gets the return type of a <paramref name="delegateType"/>.
            </summary>
            <exception cref="T:System.NotSupportedException">Reflection failure.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="delegateType"/> is not a <see langword="delegate"/>.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GetReturnParameter(System.Type)">
            <summary>
            Gets the return parameter info of a <paramref name="delegateType"/>.
            </summary>
            <exception cref="T:System.NotSupportedException">Reflection failure.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="delegateType"/> is not a <see langword="delegate"/>.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GetParameters(System.Type)">
            <summary>
            Gets the parameters of a <paramref name="delegateType"/>.
            </summary>
            <exception cref="T:System.NotSupportedException">Reflection failure.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="delegateType"/> is not a <see langword="delegate"/>.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GetInvokeMethod(System.Type)">
            <summary>
            Gets the <see langword="Invoke"/> method of a <paramref name="delegateType"/>. All delegates have one by default.
            </summary>
            <exception cref="T:System.NotSupportedException">Reflection failure.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="delegateType"/> is not a <see langword="delegate"/>.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GetMemberType(System.Reflection.MemberInfo)">
            <summary>
            Get the 'type' of a member, returns <see cref="P:System.Reflection.FieldInfo.FieldType"/> or <see cref="P:System.Reflection.PropertyInfo.PropertyType"/> or
            <see cref="P:System.Reflection.MethodInfo.ReturnType"/> or <see cref="P:System.Reflection.EventInfo.EventHandlerType"/> or <see cref="P:System.Reflection.MemberInfo.DeclaringType"/> for constructors.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GetIsStatic(System.Reflection.MemberInfo)">
            <summary>
            Check any member for being static.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.ShouldCallvirt(System.Reflection.MethodBase)">
            <summary>
            Decide if a method should be callvirt'd instead of call'd. Usually you will use <see cref="M:DanielWillett.ReflectionTools.Accessor.ShouldCallvirtRuntime(System.Reflection.MethodBase)"/> instead as it doesn't account for possible future keyword changes.
            </summary>
            <remarks>Note that not using call instead of callvirt may remove the check for a null instance.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.ShouldCallvirtRuntime(System.Reflection.MethodBase)">
            <summary>
            Decide if a method should be callvirt'd instead of call'd at runtime. Doesn't account for future changes.
            </summary>
            <remarks>Note that not using call instead of callvirt may remove the check for a null instance.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GetCall(System.Reflection.MethodBase)">
            <summary>
            Return the correct call <see cref="T:System.Reflection.Emit.OpCode"/> to use depending on the method. Usually you will use <see cref="M:DanielWillett.ReflectionTools.Accessor.GetCallRuntime(System.Reflection.MethodBase)"/> instead as it doesn't account for possible future keyword changes.
            </summary>
            <remarks>Note that not using call instead of callvirt may remove the check for a null instance.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GetCallRuntime(System.Reflection.MethodBase)">
            <summary>
            Return the correct call <see cref="T:System.Reflection.Emit.OpCode"/> to use depending on the method at runtime. Doesn't account for future changes.
            </summary>
            <remarks>Note that not using call instead of callvirt may remove the check for a null instance.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GetUnderlyingArray``1(System.Collections.Generic.List{``0})">
            <summary>
            Get the underlying array from a list.
            </summary>
            <exception cref="T:System.NotSupportedException">Reflection failure.</exception>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GetUnderlyingArrayOrCopy``1(System.Collections.Generic.List{``0})">
            <summary>
            Get the underlying array from a list, or in the case of a reflection failure calls <see cref="M:System.Collections.Generic.List`1.ToArray"/> on <paramref name="list"/> and returns that.
            </summary>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.GetListVersion``1(System.Collections.Generic.List{``0})">
            <summary>
            Get the version of a list, which is incremented each time the list is updated.
            </summary>
            <exception cref="T:System.NotSupportedException">Reflection failure.</exception>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.SetUnderlyingArray``1(System.Collections.Generic.List{``0},``0[],System.Int32)">
            <summary>
            Set the size and underlying array of a list without any validation checks.
            </summary>
            <remarks>If used incorrectly this could corrupt a list.</remarks>
            <exception cref="T:System.NotSupportedException">Reflection failure.</exception>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.TryGetUnderlyingArray``1(System.Collections.Generic.List{``0},``0[]@)">
            <summary>
            Get the underlying array from a list.
            </summary>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.TryGetListVersion``1(System.Collections.Generic.List{``0},System.Int32@)">
            <summary>
            Get the version of a list, which is incremented each time the list is updated.
            </summary>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.TrySetUnderlyingArray``1(System.Collections.Generic.List{``0},``0[],System.Int32)">
            <summary>
            Set the size and underlying array of a list without any validation checks.
            </summary>
            <remarks>If used incorrectly this could corrupt a list.</remarks>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.CouldBeAssignedTo(System.Type,System.Type)">
            <summary>
            Checks if it's possible for a variable of type <paramref name="actualType"/> to have a value of type <paramref name="queriedType"/>. 
            </summary>
            <returns><see langword="true"/> if <paramref name="actualType"/> is assignable from <paramref name="queriedType"/> or if <paramref name="queriedType"/> is assignable from <paramref name="actualType"/>.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.CouldBeAssignedTo``1(System.Type)">
            <summary>
            Checks if it's possible for a variable of type <paramref name="actualType"/> to have a value of type <typeparamref name="T"/>. 
            </summary>
            <returns><see langword="true"/> if <paramref name="actualType"/> is assignable from <typeparamref name="T"/> or if <typeparamref name="T"/> is assignable from <paramref name="actualType"/>.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.SortTypesByPriorityHandler(System.Type,System.Type)">
            <summary>
            Sort types by their priority, used for sort methods.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Accessor.SortMembersByPriorityHandler(System.Reflection.MemberInfo,System.Reflection.MemberInfo)">
            <summary>
            Sort members by their priority, used for sort methods.
            </summary>
        </member>
        <member name="T:DanielWillett.ReflectionTools.InstanceSetter`2">
            <summary>
            Represents a setter for an instance field or property.
            </summary>
            <typeparam name="TInstance">The declaring type of the member.</typeparam>
            <typeparam name="T">The return type of the member</typeparam>
        </member>
        <member name="T:DanielWillett.ReflectionTools.InstanceGetter`2">
            <summary>
            Represents a getter for an instance field or property.
            </summary>
            <typeparam name="TInstance">The declaring type of the member.</typeparam>
            <typeparam name="T">The return type of the member</typeparam>
        </member>
        <member name="T:DanielWillett.ReflectionTools.StaticSetter`1">
            <summary>
            Represents a setter for a static field or property.
            </summary>
            <typeparam name="T">The return type of the member</typeparam>
        </member>
        <member name="T:DanielWillett.ReflectionTools.StaticGetter`1">
            <summary>
            Represents a getter for a static field or property.
            </summary>
            <typeparam name="T">The return type of the member</typeparam>
        </member>
        <member name="T:DanielWillett.ReflectionTools.ForEachBaseType">
            <summary>
            Used with <see cref="M:DanielWillett.ReflectionTools.Accessor.ForEachBaseType(System.Type,DanielWillett.ReflectionTools.ForEachBaseType,System.Boolean,System.Boolean)"/>
            </summary>
            <param name="type">The current type in the hierarchy.</param>
            <param name="depth">Number of types below the provided type this base type is. Will be zero if the type returned is the provided type, 1 for its base type, and so on.</param>
        </member>
        <member name="T:DanielWillett.ReflectionTools.ForEachBaseTypeWhile">
            <summary>
            Used with <see cref="M:DanielWillett.ReflectionTools.Accessor.ForEachBaseType(System.Type,DanielWillett.ReflectionTools.ForEachBaseTypeWhile,System.Boolean,System.Boolean)"/>
            </summary>
            <param name="type">The current type in the hierarchy.</param>
            <param name="depth">Number of types below the provided type this base type is. Will be zero if the type returned is the provided type, 1 for its base type, and so on.</param>
            <returns><see langword="True"/> to continue, <see langword="false"/> to break.</returns>
        </member>
        <member name="T:DanielWillett.ReflectionTools.DefaultAccessor">
            <summary>
            Default implementation of <see cref="T:DanielWillett.ReflectionTools.IAccessor"/>.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.#ctor">
            <summary>
            Create an instance of <see cref="T:DanielWillett.ReflectionTools.DefaultAccessor"/> with a <see cref="T:DanielWillett.ReflectionTools.ConsoleReflectionToolsLogger"/> logger.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.#ctor(DanielWillett.ReflectionTools.IReflectionToolsLogger)">
            <summary>
            Create an instance of <see cref="T:DanielWillett.ReflectionTools.DefaultAccessor"/> with the specified logger.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.#ctor(DanielWillett.ReflectionTools.IReflectionToolsLogger,DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter,DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter,System.Action{DanielWillett.ReflectionTools.IAccessor},System.Boolean)">
            <summary>
            Create an instance of <see cref="T:DanielWillett.ReflectionTools.DefaultAccessor"/> with the specified logger, formatters, and configuration method.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.DefaultAccessor.LogILTraceMessages">
            <inheritdoc />
        </member>
        <member name="P:DanielWillett.ReflectionTools.DefaultAccessor.LogDebugMessages">
            <inheritdoc />
        </member>
        <member name="P:DanielWillett.ReflectionTools.DefaultAccessor.LogInfoMessages">
            <inheritdoc />
        </member>
        <member name="P:DanielWillett.ReflectionTools.DefaultAccessor.LogWarningMessages">
            <inheritdoc />
        </member>
        <member name="P:DanielWillett.ReflectionTools.DefaultAccessor.LogErrorMessages">
            <inheritdoc />
        </member>
        <member name="P:DanielWillett.ReflectionTools.DefaultAccessor.Logger">
            <inheritdoc />
        </member>
        <member name="P:DanielWillett.ReflectionTools.DefaultAccessor.Formatter">
            <inheritdoc />
        </member>
        <member name="P:DanielWillett.ReflectionTools.DefaultAccessor.ExceptionFormatter">
            <inheritdoc />
        </member>
        <member name="P:DanielWillett.ReflectionTools.DefaultAccessor.MSCoreLib">
            <inheritdoc />
        </member>
        <member name="P:DanielWillett.ReflectionTools.DefaultAccessor.IsMono">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GenerateInstanceSetter``2(System.String,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GenerateInstanceSetter``2(System.Reflection.FieldInfo,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GenerateInstanceSetter(System.Reflection.FieldInfo,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GenerateInstanceGetter``2(System.String,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GenerateInstanceGetter``2(System.Reflection.FieldInfo,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GenerateInstanceGetter(System.Reflection.FieldInfo,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GenerateInstanceSetter``1(System.Type,System.String,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GenerateInstanceSetter``1(System.Reflection.FieldInfo,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GenerateInstanceGetter``1(System.Type,System.String,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GenerateInstanceGetter``1(System.Reflection.FieldInfo,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GenerateInstancePropertySetter``2(System.String,System.Boolean,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GenerateInstancePropertyGetter``2(System.String,System.Boolean,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GenerateInstancePropertySetter``2(System.Reflection.PropertyInfo,System.Boolean,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GenerateInstancePropertyGetter``2(System.Reflection.PropertyInfo,System.Boolean,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GenerateInstancePropertySetter(System.Reflection.PropertyInfo,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GenerateInstancePropertyGetter(System.Reflection.PropertyInfo,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GenerateInstancePropertySetter``1(System.Type,System.String,System.Boolean,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GenerateInstancePropertyGetter``1(System.Type,System.String,System.Boolean,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GenerateInstancePropertySetter``1(System.Reflection.PropertyInfo,System.Boolean,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GenerateInstancePropertyGetter``1(System.Reflection.PropertyInfo,System.Boolean,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GenerateStaticSetter``2(System.String,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GenerateStaticGetter``2(System.String,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GenerateStaticSetter``1(System.Type,System.String,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GenerateStaticSetter``1(System.Reflection.FieldInfo,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GenerateStaticGetter``1(System.Type,System.String,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GenerateStaticSetter(System.Reflection.FieldInfo,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GenerateStaticGetter``1(System.Reflection.FieldInfo,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GenerateStaticGetter(System.Reflection.FieldInfo,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GenerateStaticPropertySetter``2(System.String,System.Boolean,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GenerateStaticPropertyGetter``2(System.String,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GenerateStaticPropertyGetter``2(System.String,System.Boolean,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GenerateStaticPropertySetter``1(System.Type,System.String,System.Boolean,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GenerateStaticPropertyGetter``1(System.Type,System.String,System.Boolean,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GenerateStaticPropertySetter``1(System.Reflection.PropertyInfo,System.Boolean,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GenerateStaticPropertyGetter``1(System.Reflection.PropertyInfo,System.Boolean,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GenerateStaticPropertySetter(System.Reflection.PropertyInfo,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GenerateStaticPropertyGetter(System.Reflection.PropertyInfo,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GenerateInstanceCaller``1(System.String,System.Type[],System.Boolean,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GenerateInstanceCaller``2(System.String,System.Boolean,System.Boolean,System.Type[])">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GenerateInstanceCaller(System.Reflection.MethodInfo,System.Boolean,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GenerateInstanceCaller``1(System.Reflection.MethodInfo,System.Boolean,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GenerateInstanceCaller(System.Type,System.Reflection.MethodInfo,System.Boolean,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GenerateStaticCaller``1(System.String,System.Type[],System.Boolean,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GenerateStaticCaller``2(System.String,System.Boolean,System.Boolean,System.Type[])">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GenerateStaticCaller(System.Reflection.MethodInfo,System.Boolean,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GenerateStaticCaller``1(System.Reflection.MethodInfo,System.Boolean,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GenerateStaticCaller(System.Type,System.Reflection.MethodInfo,System.Boolean,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GetDynamicMethodFlags(System.Boolean,System.Reflection.MethodAttributes@,System.Reflection.CallingConventions@)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GetVisibility(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GetVisibility(System.Reflection.MethodBase)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GetVisibility(System.Reflection.FieldInfo)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GetVisibility(System.Reflection.PropertyInfo)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GetVisibility(System.Reflection.EventInfo)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GetHighestVisibility(System.Reflection.MethodBase,System.Reflection.MethodBase)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GetHighestVisibility(System.Reflection.MethodBase,System.Reflection.MethodBase,System.Reflection.MethodBase)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GetHighestVisibility(System.Reflection.MethodBase[])">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.AssemblyGivesInternalAccess(System.Reflection.Assembly,System.String)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.IsExtern(System.Reflection.MethodBase)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.IsExtern(System.Reflection.FieldInfo)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.IsExtern(System.Reflection.PropertyInfo,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.IsDefinedSafe``1(System.Reflection.ICustomAttributeProvider,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.IsDefinedSafe(System.Reflection.ICustomAttributeProvider,System.Type,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.IsCompilerAttributeDefinedSafe(System.Reflection.ICustomAttributeProvider,System.String,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.HasAttributeSafe``1(System.Reflection.ICustomAttributeProvider,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.HasAttributeSafe(System.Reflection.ICustomAttributeProvider,System.Type,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.HasCompilerAttributeSafe(System.Reflection.ICustomAttributeProvider,System.String,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GetAttributeSafe``1(System.Reflection.ICustomAttributeProvider,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GetAttributeSafe(System.Reflection.ICustomAttributeProvider,System.Type,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GetAttributesSafe``1(System.Reflection.ICustomAttributeProvider,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GetAttributesSafe(System.Reflection.ICustomAttributeProvider,System.Type,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.TryGetAttributeSafe``1(System.Reflection.ICustomAttributeProvider,``0@,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.IsReadOnly(System.Reflection.ICustomAttributeProvider)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.IsByRefLikeType(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.IsIgnored(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.IsIgnored(System.Reflection.MemberInfo)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.IsIgnored(System.Reflection.Assembly)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.IsIgnored(System.Reflection.ParameterInfo)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.IsIgnored(System.Reflection.Module)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GetPriority(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GetPriority(System.Reflection.MemberInfo)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GetPriority(System.Reflection.Assembly)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GetPriority(System.Reflection.ParameterInfo)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GetPriority(System.Reflection.Module)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GetMethod(System.Delegate)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GetDefaultDelegate(System.Type,System.Collections.Generic.IList{System.Reflection.ParameterInfo},System.Type)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.ForEachBaseType(System.Type,DanielWillett.ReflectionTools.ForEachBaseType,System.Boolean,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.ForEachBaseType(System.Type,DanielWillett.ReflectionTools.ForEachBaseTypeWhile,System.Boolean,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GetTypesSafe(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GetTypesSafe(System.Reflection.Assembly,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GetTypesSafe(System.Collections.Generic.IEnumerable{System.Reflection.Assembly},System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GetImplementedMethod(System.Type,System.Reflection.MethodInfo)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GetDelegateSignature``1(System.Type@,System.Reflection.ParameterInfo[]@)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GetDelegateSignature``1(System.Reflection.ParameterInfo@,System.Reflection.ParameterInfo[]@)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GetReturnType``1">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GetReturnParameter``1">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GetParameters``1">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GetInvokeMethod``1">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GetDelegateSignature(System.Type,System.Type@,System.Reflection.ParameterInfo[]@)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GetDelegateSignature(System.Type,System.Reflection.ParameterInfo@,System.Reflection.ParameterInfo[]@)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GetReturnType(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GetReturnParameter(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GetParameters(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GetInvokeMethod(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GetMemberType(System.Reflection.MemberInfo)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GetIsStatic(System.Reflection.MemberInfo)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.ShouldCallvirt(System.Reflection.MethodBase)">
            <inheritdoc />s>
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.ShouldCallvirtRuntime(System.Reflection.MethodBase)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GetCall(System.Reflection.MethodBase)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GetCallRuntime(System.Reflection.MethodBase)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GetUnderlyingArray``1(System.Collections.Generic.List{``0})">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GetUnderlyingArrayOrCopy``1(System.Collections.Generic.List{``0})">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.GetListVersion``1(System.Collections.Generic.List{``0})">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.SetUnderlyingArray``1(System.Collections.Generic.List{``0},``0[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.TryGetUnderlyingArray``1(System.Collections.Generic.List{``0},``0[]@)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.TryGetListVersion``1(System.Collections.Generic.List{``0},System.Int32@)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.TrySetUnderlyingArray``1(System.Collections.Generic.List{``0},``0[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.CouldBeAssignedTo(System.Type,System.Type)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.CouldBeAssignedTo``1(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.AsEmitter(System.Reflection.Emit.ILGenerator,System.Boolean,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.AsEmitter(System.Reflection.Emit.DynamicMethod,System.Boolean,System.Boolean,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.AsEmitter(System.Reflection.Emit.MethodBuilder,System.Boolean,System.Boolean,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.AsEmitter(System.Reflection.Emit.ConstructorBuilder,System.Boolean,System.Boolean,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.AsVariable(System.Reflection.FieldInfo)">
            <inheritdoc />
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.AsVariable(System.Reflection.PropertyInfo)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.AsVariable(System.Reflection.MemberInfo)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.AsStaticVariable``1(System.Reflection.FieldInfo)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.AsStaticVariable``1(System.Reflection.PropertyInfo)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.AsInstanceVariable``2(System.Reflection.FieldInfo)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.AsInstanceVariable``2(System.Reflection.PropertyInfo)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.TryFind``1(System.String,DanielWillett.ReflectionTools.IVariable@,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.TryFind(System.Type,System.String,DanielWillett.ReflectionTools.IVariable@,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.TryFindStatic``2(System.String,DanielWillett.ReflectionTools.IStaticVariable{``1}@,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.TryFindStatic``1(System.Type,System.String,DanielWillett.ReflectionTools.IStaticVariable{``0}@,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.Find``1(System.String,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.FindStatic``2(System.String,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.Find(System.Type,System.String,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.FindStatic``1(System.Type,System.String,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.FindInstance``2(System.String,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:DanielWillett.ReflectionTools.DefaultAccessor.DelegateInfo`1">
            <summary>
            Static caching class with info about a delegate type.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.DefaultAccessor.DelegateInfo`1.InvokeMethod">
            <summary>
            The compiler-generated .Invoke method for the delegate.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.DefaultAccessor.DelegateInfo`1.Parameters">
            <summary>
            Array of all parameters in the delegate's invoke method.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.DefaultAccessor.DelegateInfo`1.ReturnType">
            <summary>
            The type the invoke method returns.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.DefaultAccessor.DelegateInfo`1.ReturnParameter">
            <summary>
            Parameter info for the return parameter.
            </summary>
        </member>
        <member name="T:DanielWillett.ReflectionTools.DefaultAccessor.ListInfo`1">
            <summary>
            Static caching class with info about a list.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.ListInfo`1.GetUnderlyingArray(System.Collections.Generic.List{`0})">
            <summary>
            Gets the underlying array from the list.
            </summary>
            <returns>Underlying array in the list.</returns>
            <exception cref="T:System.ArgumentNullException"/>
            <exception cref="T:System.NotSupportedException">Unable to find '_items' field in list.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.ListInfo`1.GetListVersion(System.Collections.Generic.List{`0})">
            <summary>
            Gets the updating version number from the list.
            </summary>
            <returns>Version number in the list.</returns>
            <exception cref="T:System.ArgumentNullException"/>
            <exception cref="T:System.NotSupportedException">Unable to find '_version' field in list.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.ListInfo`1.SetUnderlyingArray(System.Collections.Generic.List{`0},`0[],System.Int32)">
            <summary>
            Sets the underlying array and size of the list.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.ListInfo`1.TryGetUnderlyingArray(System.Collections.Generic.List{`0},`0[]@)">
            <summary>
            Gets the underlying array from the list.
            </summary>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.ListInfo`1.TryGetListVersion(System.Collections.Generic.List{`0},System.Int32@)">
            <summary>
            Gets the updating version number from the list.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.DefaultAccessor.ListInfo`1.TrySetUnderlyingArray(System.Collections.Generic.List{`0},`0[],System.Int32)">
            <summary>
            Sets the underlying array and size of the list.
            </summary>
        </member>
        <member name="T:DanielWillett.ReflectionTools.Emit.DebuggableEmitter">
            <summary>
            Wrapper for an <see cref="T:System.Reflection.Emit.ILGenerator"/> which has support for logging, both while creating the method or while executing the method.
            </summary>
            <remarks>See <see cref="P:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.DebugLog"/> and <see cref="P:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.Breakpointing"/>.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.Method">
            <summary>
            Actively editing method.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.Generator">
            <summary>
            Underlying <see cref="T:System.Reflection.Emit.ILGenerator"/>.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.ILOffset">
            <inheritdoc />
        </member>
        <member name="P:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.LogIndent">
            <summary>
            Indent level of debug logging.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.DebugLog">
            <summary>
            Enable debug logging while emitting instructions.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.Breakpointing">
            <summary>
            Enable debug logging while calling instructions.
            </summary>
            <remarks>This is done by inserting log calls for each instruction.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.LogSource">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.#ctor(System.Reflection.Emit.MethodBuilder,DanielWillett.ReflectionTools.IAccessor)">
            <summary>
            Create a <see cref="T:DanielWillett.ReflectionTools.Emit.DebuggableEmitter"/> from a <see cref="T:System.Reflection.Emit.MethodBuilder"/>.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.#ctor(System.Reflection.Emit.ConstructorBuilder,DanielWillett.ReflectionTools.IAccessor)">
            <summary>
            Create a <see cref="T:DanielWillett.ReflectionTools.Emit.DebuggableEmitter"/> from a <see cref="T:System.Reflection.Emit.ConstructorBuilder"/>.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.#ctor(System.Reflection.Emit.DynamicMethod,DanielWillett.ReflectionTools.IAccessor)">
            <summary>
            Create a <see cref="T:DanielWillett.ReflectionTools.Emit.DebuggableEmitter"/> from a <see cref="T:System.Reflection.Emit.DynamicMethod"/>.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.#ctor(DanielWillett.ReflectionTools.Emit.IOpCodeEmitter,System.Reflection.MethodBase,DanielWillett.ReflectionTools.IAccessor)">
            <summary>
            Create a <see cref="T:DanielWillett.ReflectionTools.Emit.DebuggableEmitter"/> from an <see cref="T:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter"/> and <see cref="T:System.Reflection.MethodBase"/> used for logging.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.Initialize">
            <summary>
            Write any starter logging and initialize before the first log.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.CheckInit">
            <summary>
            Run <see cref="M:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.Initialize"/> if it hasn't already been ran.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.Log(System.String)">
            <summary>
            Log a comment/verbose message.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.Log(System.Reflection.Emit.OpCode,System.Object)">
            <summary>
            Log the given <see cref="T:System.Reflection.Emit.OpCode"/> and it's operand if it exists.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.BeginCatchBlock(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.BeginExceptFilterBlock">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.BeginExceptionBlock">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.BeginFaultBlock">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.BeginFinallyBlock">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.BeginScope">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.Comment(System.String)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.DeclareLocal(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.DeclareLocal(System.Type,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.DefineLabel">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.Emit(System.Reflection.Emit.OpCode)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.Emit(System.Reflection.Emit.OpCode,System.Byte)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.Emit(System.Reflection.Emit.OpCode,System.Double)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.Emit(System.Reflection.Emit.OpCode,System.Single)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.Emit(System.Reflection.Emit.OpCode,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.Emit(System.Reflection.Emit.OpCode,System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.Emit(System.Reflection.Emit.OpCode,System.SByte)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.Emit(System.Reflection.Emit.OpCode,System.Int16)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.Emit(System.Reflection.Emit.OpCode,System.String)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.Emit(System.Reflection.Emit.OpCode,System.Reflection.ConstructorInfo)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.Label)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.Label[])">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.LocalBuilder)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.SignatureHelper)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.Emit(System.Reflection.Emit.OpCode,System.Reflection.FieldInfo)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.Emit(System.Reflection.Emit.OpCode,System.Reflection.MethodInfo)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.Emit(System.Reflection.Emit.OpCode,System.Type)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.EmitCall(System.Reflection.Emit.OpCode,System.Reflection.MethodInfo,System.Type[])">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.EmitCalli(System.Reflection.Emit.OpCode,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[])">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.EmitCalli(System.Reflection.Emit.OpCode,System.Runtime.InteropServices.CallingConvention,System.Type,System.Type[])">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.EmitWriteLine(System.String)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.EmitWriteLine(System.Reflection.Emit.LocalBuilder)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.EmitWriteLine(System.Reflection.FieldInfo)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.EndExceptionBlock">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.EndScope">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.MarkLabel(System.Reflection.Emit.Label)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.ThrowException(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.DebuggableEmitter.UsingNamespace(System.String)">
            <inheritdoc />
        </member>
        <member name="T:DanielWillett.ReflectionTools.Emit.EmitUtility">
            <summary>
            Utilities for creating dynamically generated code.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Emit.EmitUtility.AllOpCodes">
            <summary>
            A list of all op-codes sorted by their value code.
            </summary>
            <remarks>In .NET Framework 4.0 and less, this is a <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1"/> instead of <see cref="T:System.Collections.Generic.IReadOnlyList{T}"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.EmitUtility.GetOpCodeFromValue(System.Int16)">
            <summary>
            Get an op-code from it's value code, or <see langword="null"/> if the value is invalid.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.EmitUtility.GetLabelId(System.Reflection.Emit.Label)">
            <summary>
            Get the label ID from a <see cref="T:System.Reflection.Emit.Label"/> object.
            </summary>
            <remarks>Uses an unsafe cast to an integer, may not work in some non-standard .NET implementations.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.EmitUtility.EmitArgument(System.Reflection.Emit.ILGenerator,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Loads an argument from an index.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.EmitUtility.EmitArgument(DanielWillett.ReflectionTools.Emit.IOpCodeEmitter,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Loads an argument from an index.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.EmitUtility.LoadConstantI4(System.Reflection.Emit.ILGenerator,System.Int32)">
            <summary>
            Emit an Int32.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.EmitUtility.LoadConstantI4(DanielWillett.ReflectionTools.Emit.IOpCodeEmitter,System.Int32)">
            <summary>
            Emit an Int32.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.EmitUtility.EmitParameter(System.Reflection.Emit.ILGenerator,System.Int32,System.Boolean,System.Type,System.Type)">
            <summary>
            Loads a parameter from an index.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.EmitUtility.EmitParameter(DanielWillett.ReflectionTools.Emit.IOpCodeEmitter,System.Int32,System.Boolean,System.Type,System.Type)">
            <summary>
            Loads a parameter from an index.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.EmitUtility.EmitParameter(System.Reflection.Emit.ILGenerator,System.Int32,System.String,System.Boolean,System.Type,System.Type)">
            <summary>
            Loads a parameter from an index.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.EmitUtility.EmitParameter(DanielWillett.ReflectionTools.Emit.IOpCodeEmitter,System.Int32,System.String,System.Boolean,System.Type,System.Type)">
            <summary>
            Loads a parameter from an index.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.EmitUtility.IsOfType(System.Reflection.Emit.OpCode,System.Reflection.Emit.OpCode,System.Boolean)">
            <summary>
            Compare <see cref="T:System.Reflection.Emit.OpCode"/>s.
            </summary>
            <param name="opcode">Original <see cref="T:System.Reflection.Emit.OpCode"/>.</param>
            <param name="comparand"><see cref="T:System.Reflection.Emit.OpCode"/> to compare to <paramref name="opcode"/>.</param>
            <param name="fuzzy">Changes how similar <see cref="T:System.Reflection.Emit.OpCode"/>s are compared (<c>br</c> and <c>ble</c> will match, for example).</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.EmitUtility.IsStLoc(System.Reflection.Emit.OpCode)">
            <summary>
            Is this opcode any variants of <c>stloc</c>.
            </summary>
            <param name="opcode"><see cref="T:System.Reflection.Emit.OpCode"/> to check.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.EmitUtility.IsLdLoc(System.Reflection.Emit.OpCode,System.Boolean,System.Boolean)">
            <summary>
            Is this opcode any variants of <c>ldloc</c>.
            </summary>
            <param name="opcode"><see cref="T:System.Reflection.Emit.OpCode"/> to check.</param>
            <param name="byRef">Only match instructions that load by address.</param>
            <param name="either">Match instructions that load by value or address.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.EmitUtility.IsLdFld(System.Reflection.Emit.OpCode,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Is this opcode any variants of <c>ldfld</c>.
            </summary>
            <param name="opcode"><see cref="T:System.Reflection.Emit.OpCode"/> to check.</param>
            <param name="byRef">Only match instructions that load by address.</param>
            <param name="either">Match instructions that load by value or address.</param>
            <param name="static">Only match instructions that load static fields.</param>
            <param name="staticOrInstance">Match instructions that load static or instance fields.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.EmitUtility.IsStArg(System.Reflection.Emit.OpCode)">
            <summary>
            Is this opcode any variants of <c>starg</c>.
            </summary>
            <param name="opcode"><see cref="T:System.Reflection.Emit.OpCode"/> to check.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.EmitUtility.IsLdArg(System.Reflection.Emit.OpCode,System.Boolean,System.Boolean)">
            <summary>
            Is this opcode any variants of <c>stloc</c>.
            </summary>
            <param name="opcode"><see cref="T:System.Reflection.Emit.OpCode"/> to check.</param>
            <param name="byRef">Only match instructions that load by address.</param>
            <param name="either">Match instructions that load by value or address.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.EmitUtility.IsBrAny(System.Reflection.Emit.OpCode,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Is this opcode any variants of <c>br</c>.
            </summary>
            <remarks>Use <see cref="M:DanielWillett.ReflectionTools.Emit.EmitUtility.IsBr(System.Reflection.Emit.OpCode,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)"/> for the same check but all parameters default to <see langword="false"/>.</remarks>
            <param name="opcode"><see cref="T:System.Reflection.Emit.OpCode"/> to check.</param>
            <param name="br">Return <see langword="true"/> if <paramref name="opcode"/> is any variant of <c>br</c>.</param>
            <param name="brtrue">Return <see langword="true"/> if <paramref name="opcode"/> is any variant of <c>brtrue</c>.</param>
            <param name="brfalse">Return <see langword="true"/> if <paramref name="opcode"/> is any variant of <c>brfalse</c>.</param>
            <param name="beq">Return <see langword="true"/> if <paramref name="opcode"/> is any variant of <c>beq</c>.</param>
            <param name="bne">Return <see langword="true"/> if <paramref name="opcode"/> is any variant of <c>bne</c>.</param>
            <param name="bge">Return <see langword="true"/> if <paramref name="opcode"/> is any variant of <c>bge</c>.</param>
            <param name="ble">Return <see langword="true"/> if <paramref name="opcode"/> is any variant of <c>ble</c>.</param>
            <param name="bgt">Return <see langword="true"/> if <paramref name="opcode"/> is any variant of <c>bgt</c>.</param>
            <param name="blt">Return <see langword="true"/> if <paramref name="opcode"/> is any variant of <c>blt</c>.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.EmitUtility.IsBr(System.Reflection.Emit.OpCode,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Is this opcode any variants of <c>br</c>.
            </summary>
            <remarks>Use <see cref="M:DanielWillett.ReflectionTools.Emit.EmitUtility.IsBrAny(System.Reflection.Emit.OpCode,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)"/> for the same check but all parameters default to <see langword="true"/>.</remarks>
            <param name="opcode"><see cref="T:System.Reflection.Emit.OpCode"/> to check.</param>
            <param name="br">Return <see langword="true"/> if <paramref name="opcode"/> is any variant of <c>br</c>.</param>
            <param name="brtrue">Return <see langword="true"/> if <paramref name="opcode"/> is any variant of <c>brtrue</c>.</param>
            <param name="brfalse">Return <see langword="true"/> if <paramref name="opcode"/> is any variant of <c>brfalse</c>.</param>
            <param name="beq">Return <see langword="true"/> if <paramref name="opcode"/> is any variant of <c>beq</c>.</param>
            <param name="bne">Return <see langword="true"/> if <paramref name="opcode"/> is any variant of <c>bne</c>.</param>
            <param name="bge">Return <see langword="true"/> if <paramref name="opcode"/> is any variant of <c>bge</c>.</param>
            <param name="ble">Return <see langword="true"/> if <paramref name="opcode"/> is any variant of <c>ble</c>.</param>
            <param name="bgt">Return <see langword="true"/> if <paramref name="opcode"/> is any variant of <c>bgt</c>.</param>
            <param name="blt">Return <see langword="true"/> if <paramref name="opcode"/> is any variant of <c>blt</c>.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.EmitUtility.IsLdc(System.Reflection.Emit.OpCode,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Is this opcode any variants of <c>ldc</c>.
            </summary>
            <remarks>Use <see cref="M:DanielWillett.ReflectionTools.Emit.EmitUtility.IsBrAny(System.Reflection.Emit.OpCode,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)"/> for the same check but all parameters default to <see langword="true"/>.</remarks>
            <param name="opcode"><see cref="T:System.Reflection.Emit.OpCode"/> to check.</param>
            <param name="int">Return <see langword="true"/> if <paramref name="opcode"/> is any variant of <c>ldc.i4</c>.</param>
            <param name="long">Return <see langword="true"/> if <paramref name="opcode"/> is any variant of <c>ldc.i8</c>.</param>
            <param name="float">Return <see langword="true"/> if <paramref name="opcode"/> is any variant of <c>ldc.r4</c>.</param>
            <param name="double">Return <see langword="true"/> if <paramref name="opcode"/> is any variant of <c>ldc.r8</c>.</param>
            <param name="string">Return <see langword="true"/> if <paramref name="opcode"/> is any variant of <c>ldstr</c>.</param>
            <param name="null">Return <see langword="true"/> if <paramref name="opcode"/> is any variant of <c>ldnull</c>.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.EmitUtility.IsConv(System.Reflection.Emit.OpCode,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Is this opcode any variants of <c>conv</c>.
            </summary>
            <remarks>Use <see cref="M:DanielWillett.ReflectionTools.Emit.EmitUtility.IsBrAny(System.Reflection.Emit.OpCode,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)"/> for the same check but all parameters default to <see langword="true"/>.</remarks>
            <param name="opcode"><see cref="T:System.Reflection.Emit.OpCode"/> to check.</param>
            <param name="nint">Return <see langword="true"/> if <paramref name="opcode"/> is any variant of <c>conv.i</c> or <c>conv.u</c>.</param>
            <param name="byte">Return <see langword="true"/> if <paramref name="opcode"/> is any variant of <c>conv.i1</c> or <c>conv.u1</c>.</param>
            <param name="short">Return <see langword="true"/> if <paramref name="opcode"/> is any variant of <c>conv.i2</c> or <c>conv.u2</c>.</param>
            <param name="int">Return <see langword="true"/> if <paramref name="opcode"/> is any variant of <c>conv.i4</c> or <c>conv.u4</c>.</param>
            <param name="long">Return <see langword="true"/> if <paramref name="opcode"/> is any variant of <c>conv.i8</c> or <c>conv.u8</c>.</param>
            <param name="float">Return <see langword="true"/> if <paramref name="opcode"/> is any variant of <c>conv.r4</c> or <c>conv.r.un</c>.</param>
            <param name="double">Return <see langword="true"/> if <paramref name="opcode"/> is any variant of <c>conv.r8</c>.</param>
            <param name="fromUnsigned">Allow converting from unsigned checks.</param>
            <param name="toUnsigned">Allow converting to unsigned checks.</param>
            <param name="signed">Allow converting to signed checks.</param>
            <param name="overflowCheck">Allow overflow checks.</param>
            <param name="noOverflowCheck">Allow no overflow checks.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.EmitUtility.ParseOpCode(System.String)">
            <summary>
            Parse an op-code in <see langword="ilasm"/> style, ex. <c>ldarg.1</c>. Case and culture insensitive.
            </summary>
            <exception cref="T:System.ArgumentNullException">Given string was <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException">Given string was empty.</exception>
            <exception cref="T:System.FormatException">Failed to find a matching op-code.</exception>
            <exception cref="T:System.NotSupportedException">The type '<see cref="T:System.Reflection.Emit.OpCodeValues"/> is not available in this environment.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.EmitUtility.TryParseOpCode(System.String,System.Reflection.Emit.OpCode@)">
            <summary>
            Parse an op-code in <see langword="ilasm"/> style, ex. <c>ldarg.1</c>. Case and culture insensitive.
            </summary>
            <returns><see langword="true"/> if a matching op-code was found, otherwise <see langword="false"/>.</returns>
            <exception cref="T:System.NotSupportedException">The type '<see cref="T:System.Reflection.Emit.OpCodeValues"/> is not available in this environment.</exception>
        </member>
        <member name="T:DanielWillett.ReflectionTools.Emit.ILGeneratorEmitter">
            <summary>
            Wraps a <see cref="T:System.Reflection.Emit.ILGenerator"/> to implement <see cref="T:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter"/>.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.ILGeneratorEmitter.#ctor(System.Reflection.Emit.ILGenerator)">
            <summary>
            Wraps a <see cref="T:System.Reflection.Emit.ILGenerator"/> to implement <see cref="T:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter"/>.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Emit.ILGeneratorEmitter.Generator">
            <summary>
            Underlying <see cref="T:System.Reflection.Emit.ILGenerator"/> emitter.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Emit.ILGeneratorEmitter.ILOffset">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.ILGeneratorEmitter.Comment(System.String)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.ILGeneratorEmitter.BeginCatchBlock(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.ILGeneratorEmitter.BeginExceptFilterBlock">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.ILGeneratorEmitter.BeginExceptionBlock">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.ILGeneratorEmitter.BeginFaultBlock">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.ILGeneratorEmitter.BeginFinallyBlock">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.ILGeneratorEmitter.BeginScope">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.ILGeneratorEmitter.DeclareLocal(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.ILGeneratorEmitter.DeclareLocal(System.Type,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.ILGeneratorEmitter.DefineLabel">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.ILGeneratorEmitter.Emit(System.Reflection.Emit.OpCode)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.ILGeneratorEmitter.Emit(System.Reflection.Emit.OpCode,System.Byte)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.ILGeneratorEmitter.Emit(System.Reflection.Emit.OpCode,System.Double)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.ILGeneratorEmitter.Emit(System.Reflection.Emit.OpCode,System.Single)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.ILGeneratorEmitter.Emit(System.Reflection.Emit.OpCode,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.ILGeneratorEmitter.Emit(System.Reflection.Emit.OpCode,System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.ILGeneratorEmitter.Emit(System.Reflection.Emit.OpCode,System.SByte)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.ILGeneratorEmitter.Emit(System.Reflection.Emit.OpCode,System.Int16)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.ILGeneratorEmitter.Emit(System.Reflection.Emit.OpCode,System.String)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.ILGeneratorEmitter.Emit(System.Reflection.Emit.OpCode,System.Reflection.ConstructorInfo)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.ILGeneratorEmitter.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.Label)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.ILGeneratorEmitter.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.Label[])">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.ILGeneratorEmitter.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.LocalBuilder)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.ILGeneratorEmitter.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.SignatureHelper)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.ILGeneratorEmitter.Emit(System.Reflection.Emit.OpCode,System.Reflection.FieldInfo)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.ILGeneratorEmitter.Emit(System.Reflection.Emit.OpCode,System.Reflection.MethodInfo)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.ILGeneratorEmitter.Emit(System.Reflection.Emit.OpCode,System.Type)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.ILGeneratorEmitter.EmitCall(System.Reflection.Emit.OpCode,System.Reflection.MethodInfo,System.Type[])">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.ILGeneratorEmitter.EmitCalli(System.Reflection.Emit.OpCode,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[])">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.ILGeneratorEmitter.EmitCalli(System.Reflection.Emit.OpCode,System.Runtime.InteropServices.CallingConvention,System.Type,System.Type[])">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.ILGeneratorEmitter.EmitWriteLine(System.String)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.ILGeneratorEmitter.EmitWriteLine(System.Reflection.Emit.LocalBuilder)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.ILGeneratorEmitter.EmitWriteLine(System.Reflection.FieldInfo)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.ILGeneratorEmitter.EndExceptionBlock">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.ILGeneratorEmitter.EndScope">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.ILGeneratorEmitter.MarkLabel(System.Reflection.Emit.Label)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.ILGeneratorEmitter.ThrowException(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.ILGeneratorEmitter.UsingNamespace(System.String)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.ILGeneratorEmitter.op_Implicit(System.Reflection.Emit.ILGenerator)~DanielWillett.ReflectionTools.Emit.ILGeneratorEmitter">
            <summary>
            Creates an <see cref="T:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter"/> wrapper from an <see cref="T:System.Reflection.Emit.ILGenerator"/>.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.ILGeneratorEmitter.op_Implicit(DanielWillett.ReflectionTools.Emit.ILGeneratorEmitter)~System.Reflection.Emit.ILGenerator">
            <summary>
            Gets the underlying <see cref="T:System.Reflection.Emit.ILGenerator"/> from an <see cref="T:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter"/> wrapper.
            </summary>
        </member>
        <member name="T:DanielWillett.ReflectionTools.Emit.OpCodeEmitters">
            <summary>
            Extensions for <see cref="T:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter"/> objects.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.OpCodeEmitters.AsEmitter(System.Reflection.Emit.ILGenerator,System.Boolean,System.Boolean)">
            <summary>
            Extension method to get a <see cref="T:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter"/>.
            </summary>
            <param name="generator"><see cref="T:System.Reflection.Emit.ILGenerator"/> to wrap.</param>
            <param name="debuggable">Shows debug logging as the method generates.</param>
            <param name="addBreakpoints">Shows debug logging as the method executes.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.OpCodeEmitters.AsEmitter(System.Reflection.Emit.DynamicMethod,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Extension method to get a <see cref="T:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter"/>.
            </summary>
            <param name="dynMethod">Dynamic method.</param>
            <param name="debuggable">Shows debug logging as the method generates.</param>
            <param name="addBreakpoints">Shows debug logging as the method executes.</param>
            <param name="streamSize">The size of the MSIL stream, in bytes.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.OpCodeEmitters.AsEmitter(System.Reflection.Emit.MethodBuilder,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Extension method to get a <see cref="T:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter"/>.
            </summary>
            <param name="methodBuilder">Dynamic method builder.</param>
            <param name="debuggable">Shows debug logging as the method generates.</param>
            <param name="addBreakpoints">Shows debug logging as the method executes.</param>
            <param name="streamSize">The size of the MSIL stream, in bytes.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.OpCodeEmitters.AsEmitter(System.Reflection.Emit.ConstructorBuilder,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Extension method to get a <see cref="T:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter"/>.
            </summary>
            <param name="constructorBuilder">Dynamic constructor builder.</param>
            <param name="debuggable">Shows debug logging as the constructor generates.</param>
            <param name="addBreakpoints">Shows debug logging as the constructor executes.</param>
            <param name="streamSize">The size of the MSIL stream, in bytes.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.OpCodeEmitters.WithLogSource(DanielWillett.ReflectionTools.Emit.IOpCodeEmitter,System.String)">
            <summary>
            For emitters that support it (implement <see cref="T:DanielWillett.ReflectionTools.Emit.IOpCodeEmitterLogSource"/>), sets the log source to <paramref name="source"/>.
            </summary>
            <remarks>A reference to <paramref name="emitter"/> for chaining.</remarks>
        </member>
        <member name="T:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter">
            <summary>
            Abstraction of <see cref="T:System.Reflection.Emit.ILGenerator"/>.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter.ILOffset">
            <summary>Gets the current offset, in bytes, in the Microsoft intermediate language (MSIL) stream that is being emitted by the <see cref="T:System.Reflection.Emit.ILGenerator" />.</summary>
            <returns>The offset in the MSIL stream at which the next instruction will be emitted.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter.Comment(System.String)">
            <summary>
            If the implementation supports it, adds a comment to the IL code.
            </summary>
            <remarks>Does not throw <see cref="T:System.NotSupportedException"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter.BeginCatchBlock(System.Type)">
            <summary>Begins a catch block.</summary>
            <param name="exceptionType">The <see cref="T:System.Type" /> object that represents the exception.</param>
            <exception cref="T:System.ArgumentException">The catch block is within a filtered exception.</exception>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="exceptionType" /> is <see langword="null" />, and the exception filter block has not returned a value that indicates that finally blocks should be run until this catch block is located.</exception>
            <exception cref="T:System.NotSupportedException">The Microsoft intermediate language (MSIL) being generated is not currently in an exception block.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter.BeginExceptFilterBlock">
            <summary>Begins an exception block for a filtered exception.</summary>
            <exception cref="T:System.NotSupportedException">The Microsoft intermediate language (MSIL) being generated is not currently in an exception block.
            -or-
            This <see cref="T:System.Reflection.Emit.ILGenerator" /> belongs to a <see cref="T:System.Reflection.Emit.DynamicMethod" />.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter.BeginExceptionBlock">
            <summary>Begins an exception block for a non-filtered exception.</summary>
            <returns>The label for the end of the block, if the implementation supports it, otherwise <see langword="null"/>. This will leave you in the correct place to execute finally blocks or to finish the try.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter.BeginFaultBlock">
            <summary>Begins an exception fault block in the Microsoft intermediate language (MSIL) stream.</summary>
            <exception cref="T:System.NotSupportedException">The MSIL being generated is not currently in an exception block.
            -or-
            This <see cref="T:System.Reflection.Emit.ILGenerator" /> belongs to a <see cref="T:System.Reflection.Emit.DynamicMethod" />.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter.BeginFinallyBlock">
            <summary>Begins a finally block in the Microsoft intermediate language (MSIL) instruction stream.</summary>
            <exception cref="T:System.NotSupportedException">The MSIL being generated is not currently in an exception block.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter.BeginScope">
            <summary>Begins a lexical scope.</summary>
            <exception cref="T:System.NotSupportedException">This <see cref="T:System.Reflection.Emit.ILGenerator" /> belongs to a <see cref="T:System.Reflection.Emit.DynamicMethod" />.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter.DeclareLocal(System.Type)">
            <summary>Declares a local variable of the specified type.</summary>
            <param name="localType">A <see cref="T:System.Type" /> object that represents the type of the local variable.</param>
            <returns>The declared local variable.</returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="localType" /> is <see langword="null" />.</exception>
            <exception cref="T:System.InvalidOperationException">The containing type has been created by the <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter.DeclareLocal(System.Type,System.Boolean)">
            <summary>Declares a local variable of the specified type, optionally pinning the object referred to by the variable.</summary>
            <param name="localType">A <see cref="T:System.Type" /> object that represents the type of the local variable.</param>
            <param name="pinned">
            <see langword="true" /> to pin the object in memory; otherwise, <see langword="false" />.</param>
            <returns>A <see cref="T:System.Reflection.Emit.LocalBuilder" /> object that represents the local variable.</returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="localType" /> is <see langword="null" />.</exception>
            <exception cref="T:System.InvalidOperationException">The containing type has been created by the <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method.
            -or-
            The method body of the enclosing method has been created by the <see cref="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)" /> method.</exception>
            <exception cref="T:System.NotSupportedException">The method with which this <see cref="T:System.Reflection.Emit.ILGenerator" /> is associated is not represented by a <see cref="T:System.Reflection.Emit.MethodBuilder" />.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter.DefineLabel">
            <summary>Declares a new label.</summary>
            <returns>A new label that can be used as a token for branching.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter.Emit(System.Reflection.Emit.OpCode)">
            <summary>Puts the specified instruction onto the stream of instructions.</summary>
            <param name="opcode">The Microsoft Intermediate Language (MSIL) instruction to be put onto the stream.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter.Emit(System.Reflection.Emit.OpCode,System.Byte)">
            <summary>Puts the specified instruction and character argument onto the Microsoft intermediate language (MSIL) stream of instructions.</summary>
            <param name="opcode">The MSIL instruction to be put onto the stream.</param>
            <param name="arg">The character argument pushed onto the stream immediately after the instruction.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter.Emit(System.Reflection.Emit.OpCode,System.Double)">
            <summary>Puts the specified instruction and numerical argument onto the Microsoft intermediate language (MSIL) stream of instructions.</summary>
            <param name="opcode">The MSIL instruction to be put onto the stream. Defined in the <see langword="OpCodes" /> enumeration.</param>
            <param name="arg">The numerical argument pushed onto the stream immediately after the instruction.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter.Emit(System.Reflection.Emit.OpCode,System.Single)">
            <summary>Puts the specified instruction and numerical argument onto the Microsoft intermediate language (MSIL) stream of instructions.</summary>
            <param name="opcode">The MSIL instruction to be put onto the stream.</param>
            <param name="arg">The <see langword="Single" /> argument pushed onto the stream immediately after the instruction.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter.Emit(System.Reflection.Emit.OpCode,System.Int32)">
            <summary>Puts the specified instruction and numerical argument onto the Microsoft intermediate language (MSIL) stream of instructions.</summary>
            <param name="opcode">The MSIL instruction to be put onto the stream.</param>
            <param name="arg">The numerical argument pushed onto the stream immediately after the instruction.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter.Emit(System.Reflection.Emit.OpCode,System.Int64)">
            <summary>Puts the specified instruction and numerical argument onto the Microsoft intermediate language (MSIL) stream of instructions.</summary>
            <param name="opcode">The MSIL instruction to be put onto the stream.</param>
            <param name="arg">The numerical argument pushed onto the stream immediately after the instruction.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter.Emit(System.Reflection.Emit.OpCode,System.SByte)">
            <summary>Puts the specified instruction and character argument onto the Microsoft intermediate language (MSIL) stream of instructions.</summary>
            <param name="opcode">The MSIL instruction to be put onto the stream.</param>
            <param name="arg">The character argument pushed onto the stream immediately after the instruction.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter.Emit(System.Reflection.Emit.OpCode,System.Int16)">
            <summary>Puts the specified instruction and numerical argument onto the Microsoft intermediate language (MSIL) stream of instructions.</summary>
            <param name="opcode">The MSIL instruction to be emitted onto the stream.</param>
            <param name="arg">The <see langword="Int" /> argument pushed onto the stream immediately after the instruction.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter.Emit(System.Reflection.Emit.OpCode,System.String)">
            <summary>Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream followed by the metadata token for the given string.</summary>
            <param name="opcode">The MSIL instruction to be emitted onto the stream.</param>
            <param name="str">The <see langword="String" /> to be emitted.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter.Emit(System.Reflection.Emit.OpCode,System.Reflection.ConstructorInfo)">
            <summary>Puts the specified instruction and metadata token for the specified constructor onto the Microsoft intermediate language (MSIL) stream of instructions.</summary>
            <param name="opcode">The MSIL instruction to be emitted onto the stream.</param>
            <param name="con">A <see langword="ConstructorInfo" /> representing a constructor.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="con" /> is <see langword="null" />. This exception is new in the .NET Framework 4.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.Label)">
            <summary>Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream and leaves space to include a label when fixes are done.</summary>
            <param name="opcode">The MSIL instruction to be emitted onto the stream.</param>
            <param name="label">The label to which to branch from this location.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.Label[])">
            <summary>Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream and leaves space to include a label when fixes are done.</summary>
            <param name="opcode">The MSIL instruction to be emitted onto the stream.</param>
            <param name="labels">The array of label objects to which to branch from this location. All of the labels will be used.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="labels" /> is <see langword="null" />. This exception is new in the .NET Framework 4.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.LocalBuilder)">
            <summary>Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream followed by the index of the given local variable.</summary>
            <param name="opcode">The MSIL instruction to be emitted onto the stream.</param>
            <param name="local">A local variable.</param>
            <exception cref="T:System.ArgumentException">The parent method of the <paramref name="local" /> parameter does not match the method associated with this <see cref="T:System.Reflection.Emit.ILGenerator" />.</exception>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="local" /> is <see langword="null" />.</exception>
            <exception cref="T:System.InvalidOperationException">
            <paramref name="opcode" /> is a single-byte instruction, and <paramref name="local" /> represents a local variable with an index greater than <see langword="Byte.MaxValue" />.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.SignatureHelper)">
            <summary>Puts the specified instruction and a signature token onto the Microsoft intermediate language (MSIL) stream of instructions.</summary>
            <param name="opcode">The MSIL instruction to be emitted onto the stream.</param>
            <param name="signature">A helper for constructing a signature token.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="signature" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter.Emit(System.Reflection.Emit.OpCode,System.Reflection.FieldInfo)">
            <summary>Puts the specified instruction and metadata token for the specified field onto the Microsoft intermediate language (MSIL) stream of instructions.</summary>
            <param name="opcode">The MSIL instruction to be emitted onto the stream.</param>
            <param name="field">A <see langword="FieldInfo" /> representing a field.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter.Emit(System.Reflection.Emit.OpCode,System.Reflection.MethodInfo)">
            <summary>Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream followed by the metadata token for the given method.</summary>
            <param name="opcode">The MSIL instruction to be emitted onto the stream.</param>
            <param name="meth">A <see langword="MethodInfo" /> representing a method.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="meth" /> is <see langword="null" />.</exception>
            <exception cref="T:System.NotSupportedException">
            <paramref name="meth" /> is a generic method for which the <see cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" /> property is <see langword="false" />.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter.Emit(System.Reflection.Emit.OpCode,System.Type)">
            <summary>Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream followed by the metadata token for the given type.</summary>
            <param name="opcode">The MSIL instruction to be put onto the stream.</param>
            <param name="cls">A <see langword="Type" />.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="cls" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter.EmitCall(System.Reflection.Emit.OpCode,System.Reflection.MethodInfo,System.Type[])">
            <summary>Puts a <see langword="call" /> or <see langword="callvirt" /> instruction onto the Microsoft intermediate language (MSIL) stream to call a <see langword="varargs" /> method.</summary>
            <param name="opcode">The MSIL instruction to be emitted onto the stream. Must be <see cref="F:System.Reflection.Emit.OpCodes.Call" />, <see cref="F:System.Reflection.Emit.OpCodes.Callvirt" />, or <see cref="F:System.Reflection.Emit.OpCodes.Newobj" />.</param>
            <param name="methodInfo">The <see langword="varargs" /> method to be called.</param>
            <param name="optionalParameterTypes">The types of the optional arguments if the method is a <see langword="varargs" /> method; otherwise, <see langword="null" />.</param>
            <exception cref="T:System.ArgumentException">
            <paramref name="opcode" /> does not specify a method call.</exception>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="methodInfo" /> is <see langword="null" />.</exception>
            <exception cref="T:System.InvalidOperationException">The calling convention for the method is not <see langword="varargs" />, but optional parameter types are supplied. This exception is thrown in the .NET Framework versions 1.0 and 1.1, In subsequent versions, no exception is thrown.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter.EmitCalli(System.Reflection.Emit.OpCode,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[])">
            <summary>Puts a <see cref="F:System.Reflection.Emit.OpCodes.Calli" /> instruction onto the Microsoft intermediate language (MSIL) stream, specifying a managed calling convention for the indirect call.</summary>
            <param name="opcode">The MSIL instruction to be emitted onto the stream. Must be <see cref="F:System.Reflection.Emit.OpCodes.Calli" />.</param>
            <param name="callingConvention">The managed calling convention to be used.</param>
            <param name="returnType">The <see cref="T:System.Type" /> of the result.</param>
            <param name="parameterTypes">The types of the required arguments to the instruction.</param>
            <param name="optionalParameterTypes">The types of the optional arguments for <see langword="varargs" /> calls.</param>
            <exception cref="T:System.InvalidOperationException">
            <paramref name="optionalParameterTypes" /> is not <see langword="null" />, but <paramref name="callingConvention" /> does not include the <see cref="F:System.Reflection.CallingConventions.VarArgs" /> flag.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter.EmitCalli(System.Reflection.Emit.OpCode,System.Runtime.InteropServices.CallingConvention,System.Type,System.Type[])">
            <summary>Puts a <see cref="F:System.Reflection.Emit.OpCodes.Calli" /> instruction onto the Microsoft intermediate language (MSIL) stream, specifying an unmanaged calling convention for the indirect call.</summary>
            <param name="opcode">The MSIL instruction to be emitted onto the stream. Must be <see cref="F:System.Reflection.Emit.OpCodes.Calli" />.</param>
            <param name="unmanagedCallConv">The unmanaged calling convention to be used.</param>
            <param name="returnType">The <see cref="T:System.Type" /> of the result.</param>
            <param name="parameterTypes">The types of the required arguments to the instruction.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter.EmitWriteLine(System.String)">
            <summary>Emits the Microsoft intermediate language (MSIL) to call <see cref="M:System.Console.WriteLine(System.String)" /> with a string.</summary>
            <param name="value">The string to be printed.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter.EmitWriteLine(System.Reflection.Emit.LocalBuilder)">
            <summary>Emits the Microsoft intermediate language (MSIL) necessary to call <see cref="M:System.Console.WriteLine(System.Object)" /> with the given local variable.</summary>
            <param name="localBuilder">The local variable whose value is to be written to the console.</param>
            <exception cref="T:System.ArgumentException">The type of <paramref name="localBuilder" /> is <see cref="T:System.Reflection.Emit.TypeBuilder" /> or <see cref="T:System.Reflection.Emit.EnumBuilder" />, which are not supported.
            -or-
            There is no overload of <see cref="M:System.Console.WriteLine(System.Object)" /> that accepts the type of <paramref name="localBuilder" />.</exception>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="localBuilder" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter.EmitWriteLine(System.Reflection.FieldInfo)">
            <summary>Emits the Microsoft intermediate language (MSIL) necessary to call <see cref="M:System.Console.WriteLine(System.Object)" /> with the given field.</summary>
            <param name="fld">The field whose value is to be written to the console.</param>
            <exception cref="T:System.ArgumentException">There is no overload of the <see cref="M:System.Console.WriteLine(System.Object)" /> method that accepts the type of the specified field.</exception>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="fld" /> is <see langword="null" />.</exception>
            <exception cref="T:System.NotSupportedException">The type of the field is <see cref="T:System.Reflection.Emit.TypeBuilder" /> or <see cref="T:System.Reflection.Emit.EnumBuilder" />, which are not supported.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter.EndExceptionBlock">
            <summary>Ends an exception block.</summary>
            <exception cref="T:System.InvalidOperationException">The end exception block occurs in an unexpected place in the code stream.</exception>
            <exception cref="T:System.NotSupportedException">The Microsoft intermediate language (MSIL) being generated is not currently in an exception block.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter.EndScope">
            <summary>Ends a lexical scope.</summary>
            <exception cref="T:System.NotSupportedException">This <see cref="T:System.Reflection.Emit.ILGenerator" /> belongs to a <see cref="T:System.Reflection.Emit.DynamicMethod" />.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter.MarkLabel(System.Reflection.Emit.Label)">
            <summary>Marks the Microsoft intermediate language (MSIL) stream's current position with the given label.</summary>
            <param name="loc">The label for which to set an index.</param>
            <exception cref="T:System.ArgumentException">
                    <paramref name="loc" /> represents an invalid index into the label array.
            -or-
            An index for <paramref name="loc" /> has already been defined.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter.ThrowException(System.Type)">
            <summary>Emits an instruction to throw an exception.</summary>
            <param name="excType">The class of the type of exception to throw.</param>
            <exception cref="T:System.ArgumentException">
                    <paramref name="excType" /> is not the <see cref="T:System.Exception" /> class or a derived class of <see cref="T:System.Exception" />.
            -or-
            The type does not have a default constructor.</exception>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="excType" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter.UsingNamespace(System.String)">
            <summary>Specifies the namespace to be used in evaluating locals and watches for the current active lexical scope.</summary>
            <param name="usingNamespace">The namespace to be used in evaluating locals and watches for the current active lexical scope</param>
            <exception cref="T:System.ArgumentException">Length of <paramref name="usingNamespace" /> is zero.</exception>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="usingNamespace" /> is <see langword="null" />.</exception>
            <exception cref="T:System.NotSupportedException">This <see cref="T:System.Reflection.Emit.ILGenerator" /> belongs to a <see cref="T:System.Reflection.Emit.DynamicMethod" />.</exception>
        </member>
        <member name="T:DanielWillett.ReflectionTools.Emit.IOpCodeEmitterLogSource">
            <summary>
            An <see cref="T:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter"/> that supports a log source.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Emit.IOpCodeEmitterLogSource.LogSource">
            <summary>
            Source to show when debug logging.
            </summary>
        </member>
        <member name="T:DanielWillett.ReflectionTools.Formatting.ByRefTypeMode">
            <summary>
            Describes the way a by-ref type is passed as a parameter.
            </summary>
        </member>
        <member name="F:DanielWillett.ReflectionTools.Formatting.ByRefTypeMode.Ignore">
            <summary>
            Don't write a keyword in front, even if it is a by-ref type.
            </summary>
        </member>
        <member name="F:DanielWillett.ReflectionTools.Formatting.ByRefTypeMode.Ref">
            <summary>
            Represents a parameter or return type passed with <see langword="ref"/>.
            </summary>
        </member>
        <member name="F:DanielWillett.ReflectionTools.Formatting.ByRefTypeMode.In">
            <summary>
            Represents a parameter passed with <see langword="in"/>.
            </summary>
        </member>
        <member name="F:DanielWillett.ReflectionTools.Formatting.ByRefTypeMode.RefReadOnly">
            <summary>
            Represents a return type passed with <see langword="ref readonly"/>.
            </summary>
        </member>
        <member name="F:DanielWillett.ReflectionTools.Formatting.ByRefTypeMode.Out">
            <summary>
            Represents a parameter passed with <see langword="out"/>.
            </summary>
        </member>
        <member name="F:DanielWillett.ReflectionTools.Formatting.ByRefTypeMode.ScopedRef">
            <summary>
            Represents a parameter passed with <see langword="scoped ref"/>.
            </summary>
        </member>
        <member name="F:DanielWillett.ReflectionTools.Formatting.ByRefTypeMode.ScopedIn">
            <summary>
            Represents a parameter passed with <see langword="scoped in"/>.
            </summary>
        </member>
        <member name="F:DanielWillett.ReflectionTools.Formatting.ByRefTypeMode.ScopedRefReadOnly">
            <summary>
            Represents a parameter passed with <see langword="scoped ref readonly"/>.
            </summary>
        </member>
        <member name="T:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter">
            <summary>
            Default plain-text low-alloc formatter for reflection members and op-codes.
            </summary>
        </member>
        <member name="F:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.LitPrivate">
            <summary>Keyword: <see langword="private"/>.</summary>
        </member>
        <member name="F:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.LitProtected">
            <summary>Keyword: <see langword="protected"/>.</summary>
        </member>
        <member name="F:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.LitPublic">
            <summary>Keyword: <see langword="public"/>.</summary>
        </member>
        <member name="F:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.LitInternal">
            <summary>Keyword: <see langword="internal"/>.</summary>
        </member>
        <member name="F:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.LitPrivateProtected">
            <summary>Keyword: <see langword="private protected"/>.</summary>
        </member>
        <member name="F:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.LitProtectedInternal">
            <summary>Keyword: <see langword="protected internal"/>.</summary>
        </member>
        <member name="F:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.LitStatic">
            <summary>Keyword: <see langword="static"/>.</summary>
        </member>
        <member name="F:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.LitEvent">
            <summary>Keyword: <see langword="event"/>.</summary>
        </member>
        <member name="F:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.LitReadonly">
            <summary>Keyword: <see langword="readonly"/>.</summary>
        </member>
        <member name="F:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.LitConst">
            <summary>Keyword: <see langword="const"/>.</summary>
        </member>
        <member name="F:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.LitAbstract">
            <summary>Keyword: <see langword="abstract"/>.</summary>
        </member>
        <member name="F:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.LitRef">
            <summary>Keyword: <see langword="ref"/>.</summary>
        </member>
        <member name="F:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.LitScoped">
            <summary>Keyword: <see langword="scoped"/>.</summary>
        </member>
        <member name="F:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.LitOut">
            <summary>Keyword: <see langword="out"/>.</summary>
        </member>
        <member name="F:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.LitEnum">
            <summary>Keyword: <see langword="enum"/>.</summary>
        </member>
        <member name="F:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.LitClass">
            <summary>Keyword: <see langword="class"/>.</summary>
        </member>
        <member name="F:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.LitStruct">
            <summary>Keyword: <see langword="struct"/>.</summary>
        </member>
        <member name="F:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.LitInterface">
            <summary>Keyword: <see langword="interface"/>.</summary>
        </member>
        <member name="F:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.LitDelegate">
            <summary>Keyword: <see langword="delegate"/>.</summary>
        </member>
        <member name="F:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.LitThis">
            <summary>Keyword: <see langword="this"/>.</summary>
        </member>
        <member name="F:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.LitParams">
            <summary>Keyword: <see langword="params"/>.</summary>
        </member>
        <member name="F:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.LitIn">
            <summary>Keyword: <see langword="in"/>.</summary>
        </member>
        <member name="F:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.LitGet">
            <summary>Keyword: <see langword="get"/>.</summary>
        </member>
        <member name="F:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.LitSet">
            <summary>Keyword: <see langword="set"/>.</summary>
        </member>
        <member name="F:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.LitAdd">
            <summary>Keyword: <see langword="add"/>.</summary>
        </member>
        <member name="F:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.LitRemove">
            <summary>Keyword: <see langword="remove"/>.</summary>
        </member>
        <member name="F:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.LitRaise">
            <summary>Keyword: <see langword="raise"/>.</summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.#ctor">
            <summary>
            Create a formatter.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.UseFullTypeNames">
            <summary>
            Should formatted members and types use their full (namespace-declared) names? Defaults to <see langword="false"/>.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.UseTypeKeywords">
            <summary>
            Should formatted keywords for types instead of CLR type names, ex. <see langword="int"/> instead of <see langword="Int32"/>. Defaults to <see langword="true"/>.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.Clone">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.GetFormatLength(System.Reflection.Emit.OpCode)">
            <inheritdoc/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.Format(System.Reflection.Emit.OpCode,System.Span{System.Char})">
            <inheritdoc/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.GetFormatLength(System.Reflection.Emit.Label)">
            <inheritdoc/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.Format(System.Reflection.Emit.Label,System.Span{System.Char})">
            <inheritdoc/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.GetFormatLength(System.Reflection.Emit.OpCode,System.Object,DanielWillett.ReflectionTools.Formatting.OpCodeFormattingContext)">
            <inheritdoc/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.Format(System.Reflection.Emit.OpCode,System.Object,System.Span{System.Char},DanielWillett.ReflectionTools.Formatting.OpCodeFormattingContext)">
            <inheritdoc/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.GetFormatLength(System.Type,System.Boolean,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode)">
            <inheritdoc/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.Format(System.Type,System.Span{System.Char},System.Boolean,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode)">
            <inheritdoc/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.GetFormatLength(DanielWillett.ReflectionTools.Formatting.TypeDefinition,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode)">
            <inheritdoc/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.Format(DanielWillett.ReflectionTools.Formatting.TypeDefinition,System.Span{System.Char},DanielWillett.ReflectionTools.Formatting.ByRefTypeMode)">
            <inheritdoc/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.GetFormatLength(System.Reflection.MethodBase,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.Format(System.Reflection.MethodBase,System.Span{System.Char},System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.GetFormatLength(DanielWillett.ReflectionTools.Formatting.MethodDefinition)">
            <inheritdoc/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.Format(DanielWillett.ReflectionTools.Formatting.MethodDefinition,System.Span{System.Char})">
            <inheritdoc/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.GetFormatLength(System.Reflection.FieldInfo,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.Format(System.Reflection.FieldInfo,System.Span{System.Char},System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.GetFormatLength(DanielWillett.ReflectionTools.Formatting.FieldDefinition)">
            <inheritdoc/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.Format(DanielWillett.ReflectionTools.Formatting.FieldDefinition,System.Span{System.Char})">
            <inheritdoc/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.GetFormatLength(System.Reflection.PropertyInfo,System.Boolean,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.Format(System.Reflection.PropertyInfo,System.Span{System.Char},System.Boolean,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.GetFormatLength(DanielWillett.ReflectionTools.Formatting.PropertyDefinition,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.Format(DanielWillett.ReflectionTools.Formatting.PropertyDefinition,System.Span{System.Char},System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.GetFormatLength(System.Reflection.EventInfo,System.Boolean,System.Boolean,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.Format(System.Reflection.EventInfo,System.Span{System.Char},System.Boolean,System.Boolean,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.GetFormatLength(DanielWillett.ReflectionTools.Formatting.EventDefinition,System.Boolean,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.Format(DanielWillett.ReflectionTools.Formatting.EventDefinition,System.Span{System.Char},System.Boolean,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.GetFormatLength(System.Reflection.ParameterInfo,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.Format(System.Reflection.ParameterInfo,System.Span{System.Char},System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.WriteVisibility(DanielWillett.ReflectionTools.MemberVisibility,System.Int32@,System.Span{System.Char})">
            <summary>
            Write the visibilty keyword for the given visibility.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.WriteKeyword(System.ReadOnlySpan{System.Char},System.Int32@,System.Span{System.Char},System.Boolean,System.Boolean)">
            <summary>
            Write the passed literal to the output, incrimenting index.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.CountAccessorIfExists(System.Int32,DanielWillett.ReflectionTools.MemberVisibility,System.Reflection.MethodInfo,System.Int32@)">
            <summary>
            Counts the length of a property or event method with the given <paramref name="keywordLength"/>.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.GetNestedInvariantTypeNameLength(System.Type,System.Boolean)">
            <summary>
            Calculate the length of a type name without adding declaring (nesting parent) types.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.GetNonDeclaritiveTypeNameLength(System.Type,System.Type,DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.TypeMetaInfo@,System.String)">
            <summary>
            Calculate the length of a type name without adding definition keywords.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.GetNonDeclaritiveTypeNameLengthNoSetup(System.Type,DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.TypeMetaInfo@,System.String)">
            <summary>
            Calculate the length of a type name without adding definition keywords.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.GetVisibilityLength(DanielWillett.ReflectionTools.MemberVisibility)">
            <summary>
            Get the length of the visibilty keyword for the given visibility.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.GetTypeKeyword(System.Type)">
            <summary>
            Gets the language keyword for the type instead of the CLR type name, or <see langword="null"/> if the type doesn't have a keyword. Also override <see cref="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.GetTypeKeywordLength(System.Type)"/>.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.GetTypeKeywordLength(System.Type)">
            <summary>
            Gets the language keyword for the type instead of the CLR type name, or <see langword="null"/> if the type doesn't have a keyword.
            </summary>
            <returns>The length of the keyword, or -1 if there is no associated keyword.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.Format(System.Reflection.ParameterInfo,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.Format(System.Reflection.PropertyInfo,System.Boolean,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.Format(DanielWillett.ReflectionTools.Formatting.PropertyDefinition,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.Format(System.Reflection.EventInfo,System.Boolean,System.Boolean,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.Format(DanielWillett.ReflectionTools.Formatting.EventDefinition,System.Boolean,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.Format(System.Type,System.Boolean,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode)">
            <inheritdoc/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.Format(DanielWillett.ReflectionTools.Formatting.TypeDefinition,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode)">
            <inheritdoc/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.GetRefTypeLength(DanielWillett.ReflectionTools.Formatting.ByRefTypeMode)">
            <summary>
            Get the length of the by-ref type to the output.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.WriteRefType(DanielWillett.ReflectionTools.Formatting.ByRefTypeMode,System.Int32@,System.Span{System.Char})">
            <summary>
            Write the passed by-ref type to the output, incrimenting index.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.WriteParameter(System.Reflection.ParameterInfo,System.Span{System.Char},System.Int32@,DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.TypeMetaInfo@,System.Boolean)">
            <summary>
            Write parameter to buffer.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.WriteParameter(System.Reflection.ParameterInfo,System.Type,System.String,System.Span{System.Char},System.Int32@,DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.TypeMetaInfo@,System.Boolean)">
            <summary>
            Write parameter to buffer.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.WriteParameter(DanielWillett.ReflectionTools.Formatting.MethodParameterDefinition@,DanielWillett.ReflectionTools.Formatting.IMemberDefinition,System.Type,System.String,System.Span{System.Char},System.Int32@,DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.TypeMetaInfo@,System.Boolean)">
            <summary>
            Write parameter to buffer.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.WriteAccessorIfExists(System.ReadOnlySpan{System.Char},DanielWillett.ReflectionTools.MemberVisibility,System.Reflection.MethodInfo,System.Int32@,System.Span{System.Char})">
            <summary>
            Writes a property or event method with the given <paramref name="keyword"/>.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.WritePreDimensionsAndOrdering(DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.TypeMetaInfo@,System.Span{System.Char},System.Int32@)">
            <summary>
            Writes all necessary prefix element types to the output buffer.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.WritePostDimensionsAndOrdering(DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.TypeMetaInfo@,System.Span{System.Char},System.Int32@)">
            <summary>
            Writes all necessary suffix element types to the output buffer.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.Format(System.Reflection.MethodBase,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.Format(DanielWillett.ReflectionTools.Formatting.MethodDefinition)">
            <inheritdoc/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.Format(System.Reflection.FieldInfo,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.Format(DanielWillett.ReflectionTools.Formatting.FieldDefinition)">
            <inheritdoc/>
        </member>
        <member name="T:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.TypeMetaInfo">
            <summary>
            Represents info about a type for writing.
            </summary>
        </member>
        <member name="F:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.TypeMetaInfo.ElementTypesLength">
            <summary>
            Required size of <see cref="F:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.TypeMetaInfo.ElementTypes"/>.
            </summary>
        </member>
        <member name="F:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.TypeMetaInfo.ElementTypes">
            <summary>
            Pointer to the first element in a list of array dimensions (positive nums), pointers (-1), or refs (-ByRefTypeMode - 1).
            <para>
            Element meanings:
            <code>
            <br/>* dim = -1 = pointer
            <br/>* dim &gt; 0  = array of rank {n}
            <br/>* dim &lt; -1 = -(int){ByRefTypeMode} - 1
            </code>
            </para>
            </summary>
        </member>
        <member name="F:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.TypeMetaInfo.Length">
            <summary>
            Total string length of all the different ref types.
            </summary>
        </member>
        <member name="F:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.TypeMetaInfo.IsParams">
            <summary>
            If this type is a params array.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.TypeMetaInfo.LoadParameter(System.Reflection.ParameterInfo,DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter)">
            <summary>
            Initialize the values with the given parameter.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.TypeMetaInfo.LoadParameter(DanielWillett.ReflectionTools.Formatting.MethodParameterDefinition@,DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter)">
            <summary>
            Initialize the values with the given parameter.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.TypeMetaInfo.LoadRefType(DanielWillett.ReflectionTools.Formatting.ByRefTypeMode,DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter)">
            <summary>
            Initialize the values with the given by-ref type.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.TypeMetaInfo.LoadReturnType(System.Reflection.MethodBase,DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter)">
            <summary>
            Initialize the values with the given method return value.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.TypeMetaInfo.LoadReturnType(DanielWillett.ReflectionTools.Formatting.MethodDefinition,DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter)">
            <summary>
            Initialize the values with the given method return value.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.TypeMetaInfo.SetupDimensionsAndOrdering(System.Type)">
            <summary>
            Initialize the array ranks.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.TypeMetaInfo.FlipArrayGroups">
            <summary>
            Flips groups of array elements to correspond with their flipped definition notation in C#.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.TypeMetaInfo.Init(DanielWillett.ReflectionTools.Formatting.MethodParameterDefinition@,DanielWillett.ReflectionTools.Formatting.MethodDefinition,System.String@,DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter)">
            <summary>
            Initialize the values with the given type.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.TypeMetaInfo.InitReturnTypeMeta(DanielWillett.ReflectionTools.Formatting.MethodDefinition,System.String@,DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter)">
            <summary>
            Initialize the values with the given type.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.TypeMetaInfo.Init(System.Type@,System.String@,DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter)">
            <summary>
            Initialize the values with the given type.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter.TypeMetaInfo.Init(DanielWillett.ReflectionTools.Formatting.TypeDefinition,System.String@,DanielWillett.ReflectionTools.Formatting.DefaultOpCodeFormatter)">
            <summary>
            Initialize the values with the given type definition.
            </summary>
        </member>
        <member name="T:DanielWillett.ReflectionTools.Formatting.EventDefinition">
            <summary>
            Represents a shell of a event for formatting purposes.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.EventDefinition.Name">
            <summary>
            Name of the event.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.EventDefinition.DeclaringType">
            <summary>
            Type the event is declared in.
            </summary>
            <remarks>Defaults to <see langword="null"/>.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.EventDefinition.HandlerType">
            <summary>
            Type of the event handler.
            </summary>
            <exception cref="T:System.ArgumentException">HandlerType must be a delegate type.</exception>
            <remarks>Defaults to <see langword="null"/>.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.EventDefinition.IsStatic">
            <summary>
            If the method requires an instance of <see cref="P:DanielWillett.ReflectionTools.Formatting.EventDefinition.DeclaringType"/> to be accessed.
            </summary>
            <remarks>Defaults to <see langword="false"/>.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.EventDefinition.HasAdder">
            <summary>
            If this event has an <see langword="add"/> accessor.
            </summary>
            <remarks>Defaults to <see langword="true"/>.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.EventDefinition.HasRemover">
            <summary>
            If this event has a <see langword="remove"/> accessor.
            </summary>
            <remarks>Defaults to <see langword="true"/>.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.EventDefinition.HasRaiser">
            <summary>
            If this event has a <see langword="raise"/> accessor.
            </summary>
            <remarks>Defaults to <see langword="false"/>. While not supported by C#, the CLR supports a 'raise' or 'fire' method for events, which 'invokes' the event.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.EventDefinition.#ctor(System.String)">
            <summary>
            Create a event definition, starting with a event name.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.EventDefinition.FromEvent(System.Reflection.EventInfo)">
            <summary>
            Create an event definition from an existing event.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.EventDefinition.WithNoAdder">
            <summary>
            Specify that this event has no <see langword="add"/> accessor.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.EventDefinition.WithNoRemover">
            <summary>
            Specify that this event has no <see langword="remove"/> accessor.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.EventDefinition.WithRaiser">
            <summary>
            Specify that this event has a <see langword="raise"/> accessor.
            </summary>
            <remarks>While not supported by C#, the CLR supports a 'raise' or 'fire' method for events, which 'invokes' the event.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.EventDefinition.WithHandlerType``1">
            <summary>
            Set the type stored in the event.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.EventDefinition.WithHandlerType(System.Type)">
            <summary>
            Set the type stored in the event.
            </summary>
            <exception cref="T:System.ArgumentException">HandlerType must be a delegate type.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.EventDefinition.WithHandlerType(System.String)">
            <summary>
            Set the type stored in the event.
            </summary>
            <exception cref="T:System.ArgumentException">HandlerType must be a delegate type.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.EventDefinition.DeclaredIn``1(System.Boolean)">
            <summary>
            Set the declaring type of the event.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.EventDefinition.DeclaredIn(System.Type,System.Boolean)">
            <summary>
            Set the declaring type of the event.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.EventDefinition.DeclaredIn(System.String,System.Boolean)">
            <summary>
            Set the declaring type of the event.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.EventDefinition.GetFormatLength(DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.EventDefinition.Format(DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter,System.Span{System.Char})">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.EventDefinition.GetFormatLength(DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter,System.Boolean)">
            <summary>
            Calculate the length of the string returned by <see cref="M:DanielWillett.ReflectionTools.Formatting.EventDefinition.Format(DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter,System.Span{System.Char},System.Boolean)"/>.
            </summary>
            <param name="formatter">Instance of <see cref="T:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter"/> to use for the formatting.</param>
            <param name="includeAccessors">Should the accessors be put at the end.</param>
            <returns>The length in characters of this as a string.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.EventDefinition.Format(DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter,System.Span{System.Char},System.Boolean)">
            <summary>
            Format this into a string representation. Use <see cref="M:DanielWillett.ReflectionTools.Formatting.EventDefinition.GetFormatLength(DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter,System.Boolean)"/> to get the desired length of <paramref name="output"/>.
            </summary>
            <param name="output">Buffer to put the formatted characters in.</param>
            <param name="formatter">Instance of <see cref="T:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter"/> to use for the formatting.</param>
            <param name="includeAccessors">Should the accessors be put at the end.</param>
            <returns>The length in characters of this as a string that were written to <paramref name="output"/>.</returns>
            <exception cref="T:System.IndexOutOfRangeException"><paramref name="output"/> is not large enough.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.EventDefinition.Format(DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.EventDefinition.Format(DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter,System.Boolean)">
            <summary>
            Format this into a string representation.
            </summary>
            <param name="formatter">Instance of <see cref="T:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter"/> to use for the formatting.</param>
            <param name="includeAccessors">Should the accessors be put at the end.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.EventDefinition.ToString">
            <inheritdoc />
        </member>
        <member name="T:DanielWillett.ReflectionTools.Formatting.FieldDefinition">
            <summary>
            Represents a shell of a field for formatting purposes.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.FieldDefinition.Name">
            <summary>
            Name of the field.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.FieldDefinition.DeclaringType">
            <summary>
            Type the field is declared in.
            </summary>
            <remarks>Defaults to <see langword="null"/>.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.FieldDefinition.FieldType">
            <summary>
            Type the field stores.
            </summary>
            <remarks>Defaults to <see langword="null"/>.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.FieldDefinition.IsConstant">
            <summary>
            If the field is a <see langword="const"/> field.
            </summary>
            <remarks>Defaults to <see langword="false"/>. Will always be <see langword="false"/> if <see cref="P:DanielWillett.ReflectionTools.Formatting.FieldDefinition.IsConstant"/> is <see langword="false"/> or <see cref="P:DanielWillett.ReflectionTools.Formatting.FieldDefinition.IsStatic"/> is <see langword="false"/>.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.FieldDefinition.IsReadOnly">
            <summary>
            If the field is a <see langword="readonly"/> field.
            </summary>
            <remarks>Defaults to <see langword="false"/>. Will always be <see langword="true"/> if <see cref="P:DanielWillett.ReflectionTools.Formatting.FieldDefinition.IsConstant"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.FieldDefinition.IsStatic">
            <summary>
            If the method requires an instance of <see cref="P:DanielWillett.ReflectionTools.Formatting.FieldDefinition.DeclaringType"/> to be accessed.
            </summary>
            <remarks>Defaults to <see langword="false"/>. Will always be <see langword="true"/> if <see cref="P:DanielWillett.ReflectionTools.Formatting.FieldDefinition.IsConstant"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.FieldDefinition.#ctor(System.String)">
            <summary>
            Create a field definition, starting with a field name.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.FieldDefinition.FromField(System.Reflection.FieldInfo)">
            <summary>
            Create a field definition from an existing field.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.FieldDefinition.WithFieldType``1">
            <summary>
            Set the type stored in the field.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.FieldDefinition.WithFieldType(System.Type)">
            <summary>
            Set the type stored in the field.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.FieldDefinition.WithFieldType(System.String)">
            <summary>
            Set the type stored in the field.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.FieldDefinition.AsConstant">
            <summary>
            Set <see cref="P:DanielWillett.ReflectionTools.Formatting.FieldDefinition.IsConstant"/>, <see cref="P:DanielWillett.ReflectionTools.Formatting.FieldDefinition.IsReadOnly"/>, and <see cref="P:DanielWillett.ReflectionTools.Formatting.FieldDefinition.IsStatic"/> to <see langword="true"/>.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.FieldDefinition.AsReadOnly">
            <summary>
            Set <see cref="P:DanielWillett.ReflectionTools.Formatting.FieldDefinition.IsReadOnly"/> to <see langword="true"/>.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.FieldDefinition.DeclaredIn``1(System.Boolean)">
            <summary>
            Set the declaring type of the field.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.FieldDefinition.DeclaredIn(System.Type,System.Boolean)">
            <summary>
            Set the declaring type of the field.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.FieldDefinition.DeclaredIn(System.String,System.Boolean)">
            <summary>
            Set the declaring type of the field.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.FieldDefinition.GetFormatLength(DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.FieldDefinition.Format(DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter,System.Span{System.Char})">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.FieldDefinition.Format(DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.FieldDefinition.ToString">
            <inheritdoc />
        </member>
        <member name="T:DanielWillett.ReflectionTools.Formatting.IMemberDefinition">
            <summary>
            Abstracted interface for all member defintion builders.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.IMemberDefinition.Name">
            <summary>
            Name of the member.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.IMemberDefinition.DeclaringType">
            <summary>
            Type the member is declared in.
            </summary>
            <remarks>Defaults to <see langword="null"/>.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.IMemberDefinition.IsStatic">
            <summary>
            If the member requires an instance of <see cref="P:DanielWillett.ReflectionTools.Formatting.IMemberDefinition.DeclaringType"/> to be accessed.
            </summary>
            <remarks>Defaults to <see langword="false"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IMemberDefinition.NestedIn``1(System.Boolean)">
            <summary>
            Set the declaring type of the member.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IMemberDefinition.NestedIn(System.Type,System.Boolean)">
            <summary>
            Set the declaring type of the member.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IMemberDefinition.NestedIn(System.String,System.Boolean)">
            <summary>
            Set the declaring type of the member.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IMemberDefinition.GetFormatLength(DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter)">
            <summary>
            Calculate the length of the string returned by <see cref="M:DanielWillett.ReflectionTools.Formatting.IMemberDefinition.Format(DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter,System.Span{System.Char})"/>.
            </summary>
            <param name="formatter">Instance of <see cref="T:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter"/> to use for the formatting.</param>
            <returns>The length in characters of this as a string.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IMemberDefinition.Format(DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter,System.Span{System.Char})">
            <summary>
            Format this into a string representation. Use <see cref="M:DanielWillett.ReflectionTools.Formatting.IMemberDefinition.GetFormatLength(DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter)"/> to get the desired length of <paramref name="output"/>.
            </summary>
            <param name="output">Buffer to put the formatted characters in.</param>
            <param name="formatter">Instance of <see cref="T:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter"/> to use for the formatting.</param>
            <returns>The length in characters of this as a string that were written to <paramref name="output"/>.</returns>
            <exception cref="T:System.IndexOutOfRangeException"><paramref name="output"/> is not large enough.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IMemberDefinition.Format(DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter)">
            <summary>
            Format this into a string representation.
            </summary>
            <param name="formatter">Instance of <see cref="T:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter"/> to use for the formatting.</param>
        </member>
        <member name="T:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter">
            <summary>
            Formats op-codes and their operands into string values.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.GetFormatLength(System.Reflection.Emit.OpCode)">
            <summary>
            Calculate the length of the string returned by <see cref="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.Format(System.Reflection.Emit.OpCode,System.Span{System.Char})"/>.
            </summary>
            <param name="opCode">The op-code to format.</param>
            <returns>The length in characters of <paramref name="opCode"/> as a string.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.Format(System.Reflection.Emit.OpCode,System.Span{System.Char})">
            <summary>
            Format <paramref name="opCode"/> into a string representation. Use <see cref="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.GetFormatLength(System.Reflection.Emit.OpCode)"/> to get the desired length of <paramref name="output"/>.
            </summary>
            <param name="opCode">The op-code to format.</param>
            <param name="output">Buffer to put the formatted characters in.</param>
            <returns>The length in characters of <paramref name="opCode"/> as a string that were written to <paramref name="output"/>.</returns>
            <exception cref="T:System.IndexOutOfRangeException"><paramref name="output"/> is not large enough.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.GetFormatLength(System.Reflection.Emit.Label)">
            <summary>
            Calculate the length of the string returned by <see cref="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.Format(System.Reflection.Emit.Label,System.Span{System.Char})"/>.
            </summary>
            <param name="label">The label to format.</param>
            <returns>The length in characters of <paramref name="label"/> as a string.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.Format(System.Reflection.Emit.Label,System.Span{System.Char})">
            <summary>
            Format <paramref name="label"/> into a string representation. Use <see cref="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.GetFormatLength(System.Reflection.Emit.Label)"/> to get the desired length of <paramref name="output"/>.
            </summary>
            <param name="label">The label to format.</param>
            <param name="output">Buffer to put the formatted characters in.</param>
            <returns>The length in characters of <paramref name="label"/> as a string that were written to <paramref name="output"/>.</returns>
            <exception cref="T:System.IndexOutOfRangeException"><paramref name="output"/> is not large enough.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.GetFormatLength(System.Reflection.Emit.OpCode,System.Object,DanielWillett.ReflectionTools.Formatting.OpCodeFormattingContext)">
            <summary>
            Calculate the length of the string returned by <see cref="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.Format(System.Reflection.Emit.OpCode,System.Object,System.Span{System.Char},DanielWillett.ReflectionTools.Formatting.OpCodeFormattingContext)"/>.
            </summary>
            <param name="opCode">The op-code to format.</param>
            <param name="operand">Optional operand to format after the op-code name.</param>
            <param name="usageContext">Whether to format the op-code/operand pair on one line (<see cref="F:DanielWillett.ReflectionTools.Formatting.OpCodeFormattingContext.InLine"/>) or on multiple (<see cref="F:DanielWillett.ReflectionTools.Formatting.OpCodeFormattingContext.List"/>).</param>
            <returns>The length in characters of <paramref name="opCode"/> and <paramref name="operand"/> as a string.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.Format(System.Reflection.Emit.OpCode,System.Object,System.Span{System.Char},DanielWillett.ReflectionTools.Formatting.OpCodeFormattingContext)">
            <summary>
            Format <paramref name="opCode"/> and <paramref name="operand"/> into a string representation. Use <see cref="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.GetFormatLength(System.Reflection.Emit.OpCode,System.Object,DanielWillett.ReflectionTools.Formatting.OpCodeFormattingContext)"/> to get the desired length of <paramref name="output"/>.
            </summary>
            <param name="opCode">The op-code to format.</param>
            <param name="operand">Optional operand to format after the op-code name.</param>
            <param name="output">Buffer to put the formatted characters in.</param>
            <param name="usageContext">Whether to format the op-code/operand pair on one line (<see cref="F:DanielWillett.ReflectionTools.Formatting.OpCodeFormattingContext.InLine"/>) or on multiple (<see cref="F:DanielWillett.ReflectionTools.Formatting.OpCodeFormattingContext.List"/>).</param>
            <returns>The length in characters of <paramref name="opCode"/> and <paramref name="operand"/> as a string that were written to <paramref name="output"/>.</returns>
            <exception cref="T:System.IndexOutOfRangeException"><paramref name="output"/> is not large enough.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.GetFormatLength(System.Type,System.Boolean,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode)">
            <summary>
            Calculate the length of the string returned by <see cref="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.Format(System.Type,System.Span{System.Char},System.Boolean,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode)"/>.
            </summary>
            <param name="type">The type to format.</param>
            <param name="includeDefinitionKeywords">Should definition keywords such as 'struct', 'class', 'static', 'ref', 'readonly' be included.</param>
            <param name="refMode">Describes the way a by-ref type is passed as a parameter.</param>
            <returns>The length in characters of <paramref name="type"/> as a string.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.Format(System.Type,System.Span{System.Char},System.Boolean,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode)">
            <summary>
            Format <paramref name="type"/> into a string representation. Use <see cref="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.GetFormatLength(System.Type,System.Boolean,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode)"/> to get the desired length of <paramref name="output"/>.
            </summary>
            <returns>The length in characters of <paramref name="type"/> as a string that were written to <paramref name="output"/>.</returns>
            <param name="type">The type to format.</param>
            <param name="output">Buffer to put the formatted characters in.</param>
            <param name="includeDefinitionKeywords">Should definition keywords such as 'struct', 'class', 'static', 'ref', 'readonly' be included.</param>
            <param name="refMode">Describes the way a by-ref type is passed as a parameter.</param>
            <exception cref="T:System.IndexOutOfRangeException"><paramref name="output"/> is not large enough.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.GetFormatLength``1(System.Boolean,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode)">
            <summary>
            Calculate the length of the string returned by <see cref="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.Format``1(System.Span{System.Char},System.Boolean,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode)"/>.
            </summary>
            <typeparam name="T">The type to format. This type will be made by-ref if <paramref name="refMode"/> is anything but <see cref="F:DanielWillett.ReflectionTools.Formatting.ByRefTypeMode.Ignore"/>.</typeparam>
            <param name="includeDefinitionKeywords">Should definition keywords such as 'struct', 'class', 'static', 'ref', 'readonly' be included.</param>
            <param name="refMode">Describes the way a by-ref type is passed as a parameter.</param>
            <returns>The length in characters of <typeparamref name="T"/> as a string.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.Format``1(System.Span{System.Char},System.Boolean,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode)">
            <summary>
            Format <typeparam name="T"/> into a string representation. Use <see cref="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.GetFormatLength``1(System.Boolean,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode)"/> to get the desired length of <paramref name="output"/>.
            </summary>
            <returns>The length in characters of <typeparamref name="T"/> as a string that were written to <paramref name="output"/>.</returns>
            <typeparam name="T">The type to format. This type will be made by-ref if <paramref name="refMode"/> is anything but <see cref="F:DanielWillett.ReflectionTools.Formatting.ByRefTypeMode.Ignore"/>.</typeparam>
            <param name="output">Buffer to put the formatted characters in.</param>
            <param name="includeDefinitionKeywords">Should definition keywords such as 'struct', 'class', 'static', 'ref', 'readonly' be included.</param>
            <param name="refMode">Describes the way a by-ref type is passed as a parameter.</param>
            <exception cref="T:System.IndexOutOfRangeException"><paramref name="output"/> is not large enough.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.GetFormatLength(DanielWillett.ReflectionTools.Formatting.TypeDefinition,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode)">
            <summary>
            Calculate the length of the string returned by <see cref="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.Format(DanielWillett.ReflectionTools.Formatting.TypeDefinition,System.Span{System.Char},DanielWillett.ReflectionTools.Formatting.ByRefTypeMode)"/>.
            </summary>
            <param name="type">The type to format.</param>
            <param name="refMode">Describes the way a by-ref type is passed as a parameter.</param>
            <returns>The length in characters of <paramref name="type"/> as a string.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.Format(DanielWillett.ReflectionTools.Formatting.TypeDefinition,System.Span{System.Char},DanielWillett.ReflectionTools.Formatting.ByRefTypeMode)">
            <summary>
            Format <paramref name="type"/> into a string representation. Use <see cref="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.GetFormatLength(DanielWillett.ReflectionTools.Formatting.TypeDefinition,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode)"/> to get the desired length of <paramref name="output"/>.
            </summary>
            <returns>The length in characters of <paramref name="type"/> as a string that were written to <paramref name="output"/>.</returns>
            <param name="type">The type to format.</param>
            <param name="output">Buffer to put the formatted characters in.</param>
            <param name="refMode">Describes the way a by-ref type is passed as a parameter.</param>
            <exception cref="T:System.IndexOutOfRangeException"><paramref name="output"/> is not large enough.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.GetFormatLength(System.Reflection.MethodBase,System.Boolean)">
            <summary>
            Calculate the length of the string returned by <see cref="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.Format(System.Reflection.MethodBase,System.Span{System.Char},System.Boolean)"/>.
            </summary>
            <param name="method">The method to format.</param>
            <param name="includeDefinitionKeywords">Should definition keywords such as 'readonly', 'public', 'virtual', 'abtract', 'private', etc be included.</param>
            <returns>The length in characters of <paramref name="method"/> as a string.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.Format(System.Reflection.MethodBase,System.Span{System.Char},System.Boolean)">
            <summary>
            Format <paramref name="method"/> into a string representation. Use <see cref="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.GetFormatLength(System.Reflection.MethodBase,System.Boolean)"/> to get the desired length of <paramref name="output"/>.
            </summary>
            <param name="method">The method to format.</param>
            <param name="output">Buffer to put the formatted characters in.</param>
            <param name="includeDefinitionKeywords">Should definition keywords such as 'readonly', 'public', 'virtual', 'abtract', 'private', etc be included.</param>
            <returns>The length in characters of <paramref name="method"/> as a string that were written to <paramref name="output"/>.</returns>
            <exception cref="T:System.IndexOutOfRangeException"><paramref name="output"/> is not large enough.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.GetFormatLength(DanielWillett.ReflectionTools.Formatting.MethodDefinition)">
            <summary>
            Calculate the length of the string returned by <see cref="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.Format(DanielWillett.ReflectionTools.Formatting.MethodDefinition,System.Span{System.Char})"/>.
            </summary>
            <param name="method">The method to format.</param>
            <returns>The length in characters of <paramref name="method"/> as a string.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.Format(DanielWillett.ReflectionTools.Formatting.MethodDefinition,System.Span{System.Char})">
            <summary>
            Format <paramref name="method"/> into a string representation. Use <see cref="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.GetFormatLength(DanielWillett.ReflectionTools.Formatting.MethodDefinition)"/> to get the desired length of <paramref name="output"/>.
            </summary>
            <param name="method">The method to format.</param>
            <param name="output">Buffer to put the formatted characters in.</param>
            <returns>The length in characters of <paramref name="method"/> as a string that were written to <paramref name="output"/>.</returns>
            <exception cref="T:System.IndexOutOfRangeException"><paramref name="output"/> is not large enough.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.GetFormatLength(System.Reflection.FieldInfo,System.Boolean)">
            <summary>
            Calculate the length of the string returned by <see cref="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.Format(System.Reflection.FieldInfo,System.Span{System.Char},System.Boolean)"/>.
            </summary>
            <param name="field">The field to format.</param>
            <param name="includeDefinitionKeywords">Should definition keywords such as 'readonly', 'const', 'public', 'virtual', 'abtract', 'private', etc be included.</param>
            <returns>The length in characters of <paramref name="field"/> as a string.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.Format(System.Reflection.FieldInfo,System.Span{System.Char},System.Boolean)">
            <summary>
            Format <paramref name="field"/> into a string representation. Use <see cref="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.GetFormatLength(System.Reflection.FieldInfo,System.Boolean)"/> to get the desired length of <paramref name="output"/>.
            </summary>
            <param name="field">The field to format.</param>
            <param name="output">Buffer to put the formatted characters in.</param>
            <param name="includeDefinitionKeywords">Should definition keywords such as 'readonly', 'const', 'public', 'virtual', 'abtract', 'private', etc be included.</param>
            <returns>The length in characters of <paramref name="field"/> as a string that were written to <paramref name="output"/>.</returns>
            <exception cref="T:System.IndexOutOfRangeException"><paramref name="output"/> is not large enough.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.GetFormatLength(DanielWillett.ReflectionTools.Formatting.FieldDefinition)">
            <summary>
            Calculate the length of the string returned by <see cref="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.Format(DanielWillett.ReflectionTools.Formatting.FieldDefinition,System.Span{System.Char})"/>.
            </summary>
            <param name="field">The field to format.</param>
            <returns>The length in characters of <paramref name="field"/> as a string.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.Format(DanielWillett.ReflectionTools.Formatting.FieldDefinition,System.Span{System.Char})">
            <summary>
            Format <paramref name="field"/> into a string representation. Use <see cref="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.GetFormatLength(DanielWillett.ReflectionTools.Formatting.FieldDefinition)"/> to get the desired length of <paramref name="output"/>.
            </summary>
            <param name="field">The field to format.</param>
            <param name="output">Buffer to put the formatted characters in.</param>
            <returns>The length in characters of <paramref name="field"/> as a string that were written to <paramref name="output"/>.</returns>
            <exception cref="T:System.IndexOutOfRangeException"><paramref name="output"/> is not large enough.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.GetFormatLength(System.Reflection.PropertyInfo,System.Boolean,System.Boolean)">
            <summary>
            Calculate the length of the string returned by <see cref="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.Format(System.Reflection.PropertyInfo,System.Span{System.Char},System.Boolean,System.Boolean)"/>.
            </summary>
            <param name="property">The property to format.</param>
            <param name="includeAccessors">Should the accessors be put at the end.</param>
            <param name="includeDefinitionKeywords">Should definition keywords such as 'readonly', 'public', 'virtual', 'abtract', 'private', etc be included.</param>
            <returns>The length in characters of <paramref name="property"/> as a string.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.Format(System.Reflection.PropertyInfo,System.Span{System.Char},System.Boolean,System.Boolean)">
            <summary>
            Format <paramref name="property"/> into a string representation. Use <see cref="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.GetFormatLength(System.Reflection.PropertyInfo,System.Boolean,System.Boolean)"/> to get the desired length of <paramref name="output"/>.
            </summary>
            <param name="property">The property to format.</param>
            <param name="output">Buffer to put the formatted characters in.</param>
            <param name="includeAccessors">Should the accessors be put at the end.</param>
            <param name="includeDefinitionKeywords">Should definition keywords such as 'readonly', 'public', 'virtual', 'abtract', 'private', etc be included.</param>
            <returns>The length in characters of <paramref name="property"/> as a string that were written to <paramref name="output"/>.</returns>
            <exception cref="T:System.IndexOutOfRangeException"><paramref name="output"/> is not large enough.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.GetFormatLength(DanielWillett.ReflectionTools.Formatting.PropertyDefinition,System.Boolean)">
            <summary>
            Calculate the length of the string returned by <see cref="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.Format(DanielWillett.ReflectionTools.Formatting.PropertyDefinition,System.Span{System.Char},System.Boolean)"/>.
            </summary>
            <param name="property">The property to format.</param>
            <param name="includeAccessors">Should the accessors be put at the end.</param>
            <returns>The length in characters of <paramref name="property"/> as a string.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.Format(DanielWillett.ReflectionTools.Formatting.PropertyDefinition,System.Span{System.Char},System.Boolean)">
            <summary>
            Format <paramref name="property"/> into a string representation. Use <see cref="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.GetFormatLength(DanielWillett.ReflectionTools.Formatting.PropertyDefinition,System.Boolean)"/> to get the desired length of <paramref name="output"/>.
            </summary>
            <param name="property">The property to format.</param>
            <param name="output">Buffer to put the formatted characters in.</param>
            <param name="includeAccessors">Should the accessors be put at the end.</param>
            <returns>The length in characters of <paramref name="property"/> as a string that were written to <paramref name="output"/>.</returns>
            <exception cref="T:System.IndexOutOfRangeException"><paramref name="output"/> is not large enough.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.GetFormatLength(System.Reflection.EventInfo,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Calculate the length of the string returned by <see cref="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.Format(System.Reflection.EventInfo,System.Span{System.Char},System.Boolean,System.Boolean,System.Boolean)"/>.
            </summary>
            <param name="event">The event to format.</param>
            <param name="includeAccessors">Should the accessors be put at the end.</param>
            <param name="includeEventKeyword">Should the 'event' keyword be put at the beginning.</param>
            <param name="includeDefinitionKeywords">Should definition keywords such as 'readonly', 'public', 'virtual', 'abtract', 'private', etc be included.</param>
            <returns>The length in characters of <paramref name="event"/> as a string.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.Format(System.Reflection.EventInfo,System.Span{System.Char},System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Format <paramref name="event"/> into a string representation. Use <see cref="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.GetFormatLength(System.Reflection.EventInfo,System.Boolean,System.Boolean,System.Boolean)"/> to get the desired length of <paramref name="output"/>.
            </summary>
            <param name="event">The event to format.</param>
            <param name="output">Buffer to put the formatted characters in.</param>
            <param name="includeAccessors">Should the accessors be put at the end.</param>
            <param name="includeEventKeyword">Should the 'event' keyword be put at the beginning.</param>
            <param name="includeDefinitionKeywords">Should definition keywords such as 'readonly', 'public', 'virtual', 'abtract', 'private', etc be included.</param>
            <returns>The length in characters of <paramref name="event"/> as a string that were written to <paramref name="output"/>.</returns>
            <exception cref="T:System.IndexOutOfRangeException"><paramref name="output"/> is not large enough.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.GetFormatLength(DanielWillett.ReflectionTools.Formatting.EventDefinition,System.Boolean,System.Boolean)">
            <summary>
            Calculate the length of the string returned by <see cref="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.Format(DanielWillett.ReflectionTools.Formatting.EventDefinition,System.Span{System.Char},System.Boolean,System.Boolean)"/>.
            </summary>
            <param name="event">The event to format.</param>
            <param name="includeAccessors">Should the accessors be put at the end.</param>
            <param name="includeEventKeyword">Should the 'event' keyword be put at the beginning.</param>
            <returns>The length in characters of <paramref name="event"/> as a string.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.Format(DanielWillett.ReflectionTools.Formatting.EventDefinition,System.Span{System.Char},System.Boolean,System.Boolean)">
            <summary>
            Format <paramref name="event"/> into a string representation. Use <see cref="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.GetFormatLength(DanielWillett.ReflectionTools.Formatting.EventDefinition,System.Boolean,System.Boolean)"/> to get the desired length of <paramref name="output"/>.
            </summary>
            <param name="event">The event to format.</param>
            <param name="output">Buffer to put the formatted characters in.</param>
            <param name="includeAccessors">Should the accessors be put at the end.</param>
            <param name="includeEventKeyword">Should the 'event' keyword be put at the beginning.</param>
            <returns>The length in characters of <paramref name="event"/> as a string that were written to <paramref name="output"/>.</returns>
            <exception cref="T:System.IndexOutOfRangeException"><paramref name="output"/> is not large enough.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.GetFormatLength(System.Reflection.ParameterInfo,System.Boolean)">
            <summary>
            Calculate the length of the string returned by <see cref="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.Format(System.Reflection.ParameterInfo,System.Span{System.Char},System.Boolean)"/>.
            </summary>
            <param name="parameter">The parameter to format.</param>
            <param name="isExtensionThisParameter">Append a 'this' in front of the parameter like an extension method.</param>
            <returns>The length in characters of <paramref name="parameter"/> as a string.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.Format(System.Reflection.ParameterInfo,System.Span{System.Char},System.Boolean)">
            <summary>
            Format <paramref name="parameter"/> into a string representation. Use <see cref="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.GetFormatLength(System.Reflection.ParameterInfo,System.Boolean)"/> to get the desired length of <paramref name="output"/>.
            </summary>
            <param name="parameter">The parameter to format.</param>
            <param name="output">Buffer to put the formatted characters in.</param>
            <param name="isExtensionThisParameter">Append a 'this' in front of the parameter like an extension method.</param>
            <returns>The length in characters of <paramref name="parameter"/> as a string that were written to <paramref name="output"/>.</returns>
            <exception cref="T:System.IndexOutOfRangeException"><paramref name="output"/> is not large enough.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.Format(System.Reflection.Emit.OpCode)">
            <summary>
            Format <paramref name="opCode"/> into a string representation.
            </summary>
            <param name="opCode">The op-code to format.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.Format(System.Reflection.Emit.Label)">
            <summary>
            Format <paramref name="label"/> into a string representation.
            </summary>
            <param name="label">The label to format.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.Format(System.Reflection.Emit.OpCode,System.Object,DanielWillett.ReflectionTools.Formatting.OpCodeFormattingContext)">
            <summary>
            Format <paramref name="opCode"/> and <paramref name="operand"/> into a string representation.
            </summary>
            <param name="opCode">The op-code to format.</param>
            <param name="operand">Optional operand to format after the op-code name.</param>
            <param name="usageContext">Whether to format the op-code/operand pair on one line (<see cref="F:DanielWillett.ReflectionTools.Formatting.OpCodeFormattingContext.InLine"/>) or on multiple (<see cref="F:DanielWillett.ReflectionTools.Formatting.OpCodeFormattingContext.List"/>).</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.Format(System.Type,System.Boolean,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode)">
            <summary>
            Format <paramref name="type"/> into a string representation.
            </summary>
            <param name="type">The type to format.</param>
            <param name="includeDefinitionKeywords">Should definition keywords such as 'struct', 'class', 'static', 'ref', 'readonly' be included.</param>
            <param name="refMode">Describes the way a by-ref type is passed as a parameter if <paramref name="type"/> is a by-ref type..</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.Format(DanielWillett.ReflectionTools.Formatting.TypeDefinition,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode)">
            <summary>
            Format <paramref name="type"/> into a string representation.
            </summary>
            <param name="type">The type to format.</param>
            <param name="refMode">Describes the way a by-ref type is passed as a parameter if <paramref name="type"/> is a by-ref type.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.Format``1(System.Boolean,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode)">
            <summary>
            Format <typeparam name="T"/> into a string representation.
            </summary>
            <typeparam name="T">The type to format. This type will be made by-ref if <paramref name="refMode"/> is anything but <see cref="F:DanielWillett.ReflectionTools.Formatting.ByRefTypeMode.Ignore"/>.</typeparam>
            <param name="includeDefinitionKeywords">Should definition keywords such as 'struct', 'class', 'static', 'ref', 'readonly' be included.</param>
            <param name="refMode">Describes the way a by-ref type is passed as a parameter.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.Format(System.Reflection.MethodBase,System.Boolean)">
            <summary>
            Format <paramref name="method"/> into a string representation.
            </summary>
            <param name="method">The method to format.</param>
            <param name="includeDefinitionKeywords">Should definition keywords such as 'readonly', 'public', 'virtual', 'abtract', 'private', etc be included.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.Format(DanielWillett.ReflectionTools.Formatting.MethodDefinition)">
            <summary>
            Format <paramref name="method"/> into a string representation.
            </summary>
            <param name="method">The method to format.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.Format(System.Reflection.FieldInfo,System.Boolean)">
            <summary>
            Format <paramref name="field"/> into a string representation.
            </summary>
            <param name="field">The field to format.</param>
            <param name="includeDefinitionKeywords">Should definition keywords such as 'readonly', 'const', 'public', 'virtual', 'abtract', 'private', etc be included.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.Format(DanielWillett.ReflectionTools.Formatting.FieldDefinition)">
            <summary>
            Format <paramref name="field"/> into a string representation.
            </summary>
            <param name="field">The field to format.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.Format(System.Reflection.PropertyInfo,System.Boolean,System.Boolean)">
            <summary>
            Format <paramref name="property"/> into a string representation.
            </summary>
            <param name="property">The property to format.</param>
            <param name="includeAccessors">Should the accessors be put at the end.</param>
            <param name="includeDefinitionKeywords">Should definition keywords such as 'readonly', 'public', 'virtual', 'abtract', 'private', etc be included.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.Format(DanielWillett.ReflectionTools.Formatting.PropertyDefinition,System.Boolean)">
            <summary>
            Format <paramref name="property"/> into a string representation.
            </summary>
            <param name="property">The property to format.</param>
            <param name="includeAccessors">Should the accessors be put at the end.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.Format(System.Reflection.EventInfo,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Format <paramref name="event"/> into a string representation.
            </summary>
            <param name="event">The event to format.</param>
            <param name="includeAccessors">Should the accessors be put at the end.</param>
            <param name="includeEventKeyword">Should the 'event' keyword be put at the beginning.</param>
            <param name="includeDefinitionKeywords">Should definition keywords such as 'readonly', 'public', 'virtual', 'abtract', 'private', etc be included.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.Format(DanielWillett.ReflectionTools.Formatting.EventDefinition,System.Boolean,System.Boolean)">
            <summary>
            Format <paramref name="event"/> into a string representation.
            </summary>
            <param name="event">The event to format.</param>
            <param name="includeAccessors">Should the accessors be put at the end.</param>
            <param name="includeEventKeyword">Should the 'event' keyword be put at the beginning.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter.Format(System.Reflection.ParameterInfo,System.Boolean)">
            <summary>
            Format <paramref name="parameter"/> into a string representation.
            </summary>
            <param name="parameter">The parameter to format.</param>
            <param name="isExtensionThisParameter">Append a 'this' in front of the parameter like an extension method.</param>
        </member>
        <member name="T:DanielWillett.ReflectionTools.Formatting.MethodDefinition">
            <summary>
            Represents a shell of a method for formatting purposes.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.MethodDefinition.Name">
            <summary>
            Name of the method.
            </summary>
            <exception cref="T:System.InvalidOperationException">Can not set a name on a DelegateMethodDefinition.</exception>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.MethodDefinition.IsConstructor">
            <summary>
            If this method is a constructor for <see cref="P:DanielWillett.ReflectionTools.Formatting.MethodDefinition.DeclaringType"/>.
            </summary>
            <remarks>Defaults to <see langword="false"/>.</remarks>
            <exception cref="T:System.InvalidOperationException">Can not create a constructor with a DelegateMethodDefinition.</exception>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.MethodDefinition.DeclaringType">
            <summary>
            Type the method is declared in.
            </summary>
            <remarks>Defaults to <see langword="null"/>.</remarks>
            <exception cref="T:System.InvalidOperationException">Can not set a declaring type on a DelegateMethodDefinition.</exception>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.MethodDefinition.ReturnType">
            <summary>
            Type the method returns, or <see langword="void"/>.
            </summary>
            <remarks>Defaults to <see langword="null"/>.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.MethodDefinition.ReturnTypeGenericIndex">
            <summary>
            Index of the return type in <see cref="P:DanielWillett.ReflectionTools.Formatting.MethodDefinition.GenericDefinitions"/>.
            </summary>
            <remarks>Defaults to -1.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.MethodDefinition.ReturnTypeGenericTypeElementTypes">
            <summary>
            Array of int values defining how the generic type index is manipulated as an element type.
            <para>
            Element meanings:
            <code>
            <br/>* dim = -1 = pointer
            <br/>* dim &gt; 0  = array of rank {n}
            <br/>* dim &lt; -1 = -(int){ByRefTypeMode} - 1
            </code>
            </para>
            </summary>
            <remarks>Defaults to <see langword="null"/>.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.MethodDefinition.ReturnTypeGenericTypeElementTypesLength">
            <summary>
            Actual length of <see cref="P:DanielWillett.ReflectionTools.Formatting.MethodDefinition.ReturnTypeGenericTypeElementTypes"/>, as it could be from the underlying array of a list.
            </summary>
            <remarks>Defaults to -1.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.MethodDefinition.ReturnRefTypeMode">
            <summary>
            By-ref keyword of the value the method returns.
            </summary>
            <remarks>Defaults to <see cref="F:DanielWillett.ReflectionTools.Formatting.ByRefTypeMode.Ignore"/>.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.MethodDefinition.IsStatic">
            <summary>
            If the method requires an instance of <see cref="P:DanielWillett.ReflectionTools.Formatting.MethodDefinition.DeclaringType"/> to be invoked.
            </summary>
            <remarks>Defaults to <see langword="false"/>. Always will be <see langword="true"/> if <see cref="P:DanielWillett.ReflectionTools.Formatting.MethodDefinition.IsExtensionMethod"/> is <see langword="true"/>.</remarks>
            <exception cref="T:System.InvalidOperationException">Can not create a static method with a DelegateMethodDefinition.</exception>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.MethodDefinition.IsExtensionMethod">
            <summary>
            If the method is a static extension method (the first parameter is 'this').
            </summary>
            <remarks>Defaults to <see langword="false"/>. Always will be <see langword="false"/> if <see cref="P:DanielWillett.ReflectionTools.Formatting.MethodDefinition.IsStatic"/> is <see langword="false"/>.</remarks>
            <exception cref="T:System.InvalidOperationException">Can not create a static extension method with a DelegateMethodDefinition.</exception>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.MethodDefinition.Parameters">
            <summary>
            All parameters in the method. <see langword="null"/> if no parameters are provided.
            </summary>
            <remarks>Defaults to <see langword="null"/> (parameters not specified).</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.MethodDefinition.GenericDefinitions">
            <summary>
            All generic parameter definitions in the method. <see langword="null"/> if no definitions are provided.
            </summary>
            <remarks>Defaults to <see langword="null"/> (parameters not specified).</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.MethodDefinition.GenericParameters">
            <summary>
            All generic parameter values in the method. <see langword="null"/> if no generic parameter values are provided.
            </summary>
            <remarks>Defaults to <see langword="null"/> (parameters not specified).</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.FromDelegate``1(System.String,DanielWillett.ReflectionTools.IAccessor)">
            <summary>
            Creates a <see cref="T:DanielWillett.ReflectionTools.Formatting.MethodDefinition"/> from a delegate.
            </summary>
            <param name="methodName">The name of the new method to create.</param>
            <param name="accessor">Instance of <see cref="T:DanielWillett.ReflectionTools.IAccessor"/> to use, defaulting to <see cref="P:DanielWillett.ReflectionTools.Accessor.Active"/>.</param>
            <typeparam name="TDelegate">The delegate type to use as the starting point for this <see cref="T:DanielWillett.ReflectionTools.Formatting.MethodDefinition"/>.</typeparam>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.FromDelegate(System.Type,System.String,DanielWillett.ReflectionTools.IAccessor)">
            <summary>
            Creates a <see cref="T:DanielWillett.ReflectionTools.Formatting.MethodDefinition"/> from a delegate.
            </summary>
            <param name="delegateType">The delegate type to use as the starting point for this <see cref="T:DanielWillett.ReflectionTools.Formatting.MethodDefinition"/>. Must be a delegate type</param>
            <param name="methodName">The name of the new method to create.</param>
            <param name="accessor">Instance of <see cref="T:DanielWillett.ReflectionTools.IAccessor"/> to use, defaulting to <see cref="P:DanielWillett.ReflectionTools.Accessor.Active"/>.</param>
            <exception cref="T:System.ArgumentException"><paramref name="delegateType"/> is not a delegate type.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="delegateType"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.FromMethod(System.Reflection.MethodBase,DanielWillett.ReflectionTools.IAccessor)">
            <summary>
            Creates a <see cref="T:DanielWillett.ReflectionTools.Formatting.MethodDefinition"/> from an already-existing method.
            </summary>
            <param name="method">The already-existing method.</param>
            <param name="accessor">Instance of <see cref="T:DanielWillett.ReflectionTools.IAccessor"/> to use, defaulting to <see cref="P:DanielWillett.ReflectionTools.Accessor.Active"/>.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.#ctor(System.String)">
            <summary>
            Create a method definition, starting with a method name.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.#ctor(System.Type,System.Boolean)">
            <summary>
            Create a constructor definition, starting with a return type and declaring type.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.AsExtensionMethod">
            <summary>
            Set this method to an extension method.
            </summary>
            <exception cref="T:System.InvalidOperationException">Can not create a static extension method with a DelegateMethodDefinition.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.WithReturnRefMode(DanielWillett.ReflectionTools.Formatting.ByRefTypeMode)">
            <summary>
            Set the method's by-ref return type.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.ReturningVoid">
            <summary>
            Set the return type of the method to <see langword="void"/>.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.Returning``1(DanielWillett.ReflectionTools.Formatting.ByRefTypeMode)">
            <summary>
            Set the return type of the method.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.Returning(System.Type,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode)">
            <summary>
            Set the return type of the method.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.Returning(System.String,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode)">
            <summary>
            Set the return type of the method.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.ReturningUsingGeneric(System.Int32,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode,System.Action{DanielWillett.ReflectionTools.Formatting.IGenericReferencingReturnTypeBuilder})">
            <summary>
            Create a return type which uses a generic parameter in <see cref="P:DanielWillett.ReflectionTools.Formatting.MethodDefinition.GenericDefinitions"/> as it's base element type.
            </summary>
            <param name="genericParameterIndex">The zero-based index of the generic parameter definition in <see cref="P:DanielWillett.ReflectionTools.Formatting.MethodDefinition.GenericDefinitions"/>.</param>
            <param name="byRefMode">The by-ref keyword of the return type.</param>
            <param name="elements">Optional action used to configure the return value, allowing you to make it an array, pointer, etc.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.ReturningUsingGeneric(System.String,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode,System.Action{DanielWillett.ReflectionTools.Formatting.IGenericReferencingReturnTypeBuilder})">
            <summary>
            Create a return type which uses a generic parameter in <see cref="P:DanielWillett.ReflectionTools.Formatting.MethodDefinition.GenericDefinitions"/> as it's base element type.
            </summary>
            <param name="genericParameterTypeName">Definition name of a type already declared.</param>
            <param name="byRefMode">The by-ref keyword of the return type.</param>
            <param name="elements">Optional action used to configure the return value, allowing you to make it an array, pointer, etc.</param>
            <exception cref="T:System.ArgumentException">Unknown generic definition type name: <paramref name="genericParameterTypeName"/>.</exception>
            <exception cref="T:System.ArgumentNullException" />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.DeclaredIn``1(System.Boolean)">
            <summary>
            Set the declaring type of the method.
            </summary>
            <exception cref="T:System.InvalidOperationException">Can not create a static extension method with a DelegateMethodDefinition.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.DeclaredIn(System.Type,System.Boolean)">
            <summary>
            Set the declaring type of the method.
            </summary>
            <exception cref="T:System.InvalidOperationException">Can not create a static extension method with a DelegateMethodDefinition.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.DeclaredIn(System.String,System.Boolean)">
            <summary>
            Set the declaring type of the method.
            </summary>
            <exception cref="T:System.InvalidOperationException">Can not create a static extension method with a DelegateMethodDefinition.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.WithNoParameters">
            <summary>
            Specify the method is parameterless.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.WithParameter(DanielWillett.ReflectionTools.Formatting.MethodParameterDefinition@)">
            <summary>
            Add a parameter to the parameter list.
            </summary>
            <remarks>See <see cref="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.WithParameterUsingGeneric(System.Int32,System.String,System.Boolean,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode,System.Action{DanielWillett.ReflectionTools.Formatting.IGenericReferencingParameterBuilder})"/> to reference a generic type parameter definition.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.WithParameter(System.Type,System.String)">
            <summary>
            Add a parameter to the parameter list.
            </summary>
            <remarks>See <see cref="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.WithParameterUsingGeneric(System.Int32,System.String,System.Boolean,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode,System.Action{DanielWillett.ReflectionTools.Formatting.IGenericReferencingParameterBuilder})"/> to reference a generic type parameter definition.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.WithParameter(System.Type,System.String,System.Boolean)">
            <summary>
            Add a parameter to the parameter list.
            </summary>
            <remarks>See <see cref="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.WithParameterUsingGeneric(System.Int32,System.String,System.Boolean,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode,System.Action{DanielWillett.ReflectionTools.Formatting.IGenericReferencingParameterBuilder})"/> to reference a generic type parameter definition.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.WithParameter(System.Type,System.String,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode)">
            <summary>
            Add a parameter to the parameter list.
            </summary>
            <remarks>See <see cref="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.WithParameterUsingGeneric(System.Int32,System.String,System.Boolean,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode,System.Action{DanielWillett.ReflectionTools.Formatting.IGenericReferencingParameterBuilder})"/> to reference a generic type parameter definition.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.WithParameter(System.Type,System.String,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode,System.Boolean)">
            <summary>
            Add a parameter to the parameter list.
            </summary>
            <remarks>See <see cref="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.WithParameterUsingGeneric(System.Int32,System.String,System.Boolean,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode,System.Action{DanielWillett.ReflectionTools.Formatting.IGenericReferencingParameterBuilder})"/> to reference a generic type parameter definition.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.WithParameter``1(System.String)">
            <summary>
            Add a parameter to the parameter list.
            </summary>
            <remarks>See <see cref="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.WithParameterUsingGeneric(System.Int32,System.String,System.Boolean,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode,System.Action{DanielWillett.ReflectionTools.Formatting.IGenericReferencingParameterBuilder})"/> to reference a generic type parameter definition.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.WithParameter``1(System.String,System.Boolean)">
            <summary>
            Add a parameter to the parameter list.
            </summary>
            <remarks>See <see cref="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.WithParameterUsingGeneric(System.Int32,System.String,System.Boolean,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode,System.Action{DanielWillett.ReflectionTools.Formatting.IGenericReferencingParameterBuilder})"/> to reference a generic type parameter definition.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.WithParameter``1(System.String,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode)">
            <summary>
            Add a parameter to the parameter list.
            </summary>
            <remarks>See <see cref="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.WithParameterUsingGeneric(System.Int32,System.String,System.Boolean,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode,System.Action{DanielWillett.ReflectionTools.Formatting.IGenericReferencingParameterBuilder})"/> to reference a generic type parameter definition.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.WithParameter``1(System.String,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode,System.Boolean)">
            <summary>
            Add a parameter to the parameter list.
            </summary>
            <remarks>See <see cref="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.WithParameterUsingGeneric(System.Int32,System.String,System.Boolean,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode,System.Action{DanielWillett.ReflectionTools.Formatting.IGenericReferencingParameterBuilder})"/> to reference a generic type parameter definition.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.WithParameter(System.String,System.String)">
            <summary>
            Add a parameter to the parameter list.
            </summary>
            <remarks>See <see cref="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.WithParameterUsingGeneric(System.Int32,System.String,System.Boolean,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode,System.Action{DanielWillett.ReflectionTools.Formatting.IGenericReferencingParameterBuilder})"/> to reference a generic type parameter definition.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.WithParameter(System.String,System.String,System.Boolean)">
            <summary>
            Add a parameter to the parameter list.
            </summary>
            <remarks>See <see cref="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.WithParameterUsingGeneric(System.Int32,System.String,System.Boolean,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode,System.Action{DanielWillett.ReflectionTools.Formatting.IGenericReferencingParameterBuilder})"/> to reference a generic type parameter definition.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.WithParameter(System.String,System.String,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode)">
            <summary>
            Add a parameter to the parameter list.
            </summary>
            <remarks>See <see cref="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.WithParameterUsingGeneric(System.Int32,System.String,System.Boolean,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode,System.Action{DanielWillett.ReflectionTools.Formatting.IGenericReferencingParameterBuilder})"/> to reference a generic type parameter definition.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.WithParameter(System.String,System.String,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode,System.Boolean)">
            <summary>
            Add a parameter to the parameter list.
            </summary>
            <remarks>See <see cref="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.WithParameterUsingGeneric(System.Int32,System.String,System.Boolean,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode,System.Action{DanielWillett.ReflectionTools.Formatting.IGenericReferencingParameterBuilder})"/> to reference a generic type parameter definition.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.WithParameterUsingGeneric(System.Int32,System.String,System.Boolean,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode,System.Action{DanielWillett.ReflectionTools.Formatting.IGenericReferencingParameterBuilder})">
            <summary>
            Create a return type which uses a generic parameter in <see cref="P:DanielWillett.ReflectionTools.Formatting.MethodDefinition.GenericDefinitions"/> as it's base element type.
            </summary>
            <param name="genericParameterIndex">The zero-based index of the generic parameter definition in <see cref="P:DanielWillett.ReflectionTools.Formatting.MethodDefinition.GenericDefinitions"/>.</param>
            <param name="parameterName">The name of the new parameter.</param>
            <param name="isParams">If the new parameter is a params (remainder) parameter.</param>
            <param name="byRefMode">The by-ref keyword of the parameter.</param>
            <param name="elements">Action used to configure the return value, allowing you to make it an array, pointer, etc.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.WithParameterUsingGeneric(System.String,System.String,System.Boolean,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode,System.Action{DanielWillett.ReflectionTools.Formatting.IGenericReferencingParameterBuilder})">
            <summary>
            Start a <see cref="T:DanielWillett.ReflectionTools.Formatting.IGenericReferencingParameterBuilder"/> with the given generic parameter definition to create a parameter with the base element type pulled from the generic type definitions.
            </summary>
            <param name="genericParameterTypeName">Definition name of a type already declared.</param>
            <param name="parameterName">The name of the new parameter.</param>
            <param name="isParams">If the new parameter is a params (remainder) parameter.</param>
            <param name="byRefMode">The by-ref keyword of the parameter.</param>
            <param name="elements">Action used to configure the return value, allowing you to make it an array, pointer, etc.</param>
            <exception cref="T:System.ArgumentException">Unknown generic definition type name: <paramref name="genericParameterTypeName"/>.</exception>
            <exception cref="T:System.ArgumentNullException" />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.WithGenericParameterDefinition(System.String)">
            <summary>
            Add a generic parameter definition to the generic definitions list.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.WithGenericParameterValue(System.Type)">
            <summary>
            Add a generic parameter value to the generic parameters list.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.WithGenericParameterValue``1">
            <summary>
            Add a generic parameter value to the generic parameters list.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.WithGenericParameterValue(System.String)">
            <summary>
            Add a generic parameter value to the generic parameters list.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.DanielWillett#ReflectionTools#Formatting#IMemberDefinition#NestedIn``1(System.Boolean)">
            <inheritdoc />
            <exception cref="T:System.InvalidOperationException">Can not create a static extension method with a DelegateMethodDefinition.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.DanielWillett#ReflectionTools#Formatting#IMemberDefinition#NestedIn(System.Type,System.Boolean)">
            <inheritdoc />
            <exception cref="T:System.InvalidOperationException">Can not create a static extension method with a DelegateMethodDefinition.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.DanielWillett#ReflectionTools#Formatting#IMemberDefinition#NestedIn(System.String,System.Boolean)">
            <inheritdoc />
            <exception cref="T:System.InvalidOperationException">Can not create a static extension method with a DelegateMethodDefinition.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.GetFormatLength(DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.Format(DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter,System.Span{System.Char})">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.Format(DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodDefinition.ToString">
            <inheritdoc />
        </member>
        <member name="T:DanielWillett.ReflectionTools.Formatting.DelegateMethodDefinition">
            <summary>
            Wrapper for <see cref="T:DanielWillett.ReflectionTools.Formatting.MethodDefinition"/> used for creating delegate types with <see cref="T:DanielWillett.ReflectionTools.Formatting.DelegateTypeDefinition"/>.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.DelegateMethodDefinition.#ctor">
            <summary>
            Wrapper for <see cref="T:DanielWillett.ReflectionTools.Formatting.MethodDefinition"/> used for creating delegate types with <see cref="T:DanielWillett.ReflectionTools.Formatting.DelegateTypeDefinition"/>.
            </summary>
        </member>
        <member name="T:DanielWillett.ReflectionTools.Formatting.MethodParameterDefinition">
            <summary>
            Defines a template for a method parameter.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.MethodParameterDefinition.Type">
            <summary>
            Parameter type.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.MethodParameterDefinition.GenericTypeIndex">
            <summary>
            Index of this parameter's generic type definition.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.MethodParameterDefinition.GenericTypeElementTypes">
            <summary>
            Array of int values defining how the generic type index is manipulated as an element type.
            <para>
            Element meanings:
            <code>
            <br/>* dim = -1 = pointer
            <br/>* dim &gt; 0  = array of rank {n}
            <br/>* dim &lt; -1 = -(int){ByRefTypeMode} - 1
            </code>
            </para>
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.MethodParameterDefinition.GenericTypeElementTypesLength">
            <summary>
            Actual length of <see cref="P:DanielWillett.ReflectionTools.Formatting.MethodParameterDefinition.GenericTypeElementTypes"/>, as it could be from the underlying array of a list.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.MethodParameterDefinition.Name">
            <summary>
            Optional parameter name.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.MethodParameterDefinition.ByRefMode">
            <summary>
            What keyword to use for the by-ref passing mode, if any.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.MethodParameterDefinition.IsParams">
            <summary>
            Is this parameter a <see langword="params"/> (remainder) array?
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodParameterDefinition.#ctor(System.Type,System.String)">
            <summary>
            Create a parameter with just a type and name.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodParameterDefinition.#ctor(System.Type,System.String,System.Boolean)">
            <summary>
            Create a parameter with just a type and name, along with if it's a <see langword="params"/> array.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodParameterDefinition.#ctor(System.Type,System.String,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode)">
            <summary>
            Create a parameter with just a type and name, along with what <paramref name="byRefMode"/> to use.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodParameterDefinition.#ctor(System.Type,System.String,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode,System.Boolean)">
            <summary>
            Create a parameter with just a type and name, along with if it's a <see langword="params"/> array and what <paramref name="byRefMode"/> to use.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.MethodParameterDefinition.ToString">
            <inheritdoc />
        </member>
        <member name="T:DanielWillett.ReflectionTools.Formatting.IGenericReferencingBuilder">
            <summary>
            Abstraction used for an object that creates a relationship which references a generic parameter of the method it's defined in.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.IGenericReferencingBuilder.GenericParameterIndex">
            <summary>
            Index in <see cref="P:DanielWillett.ReflectionTools.Formatting.MethodDefinition.GenericDefinitions"/> that this parameter references.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Tried to change this object after it's been completed.</exception>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.IGenericReferencingBuilder.ByRefMode">
            <summary>
            What keyword to use for the by-ref passing mode, if any.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Tried to change this object after it's been completed.</exception>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.IGenericReferencingBuilder.Depth">
            <summary>
            Current number of types that are wrapped around the original element type.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IGenericReferencingBuilder.AddArray(System.Int32)">
            <summary>
            Add an array with the specified rank (dimension).
            </summary>
            <remarks>Keep in mind arrays of arrays are usually defined backwards so groups of sequential arrays should be defined as you would write it in C# (backwards).</remarks>
            <param name="rank">Number of dimensions the array has.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Rank must be 1 or higher.</exception>
            <exception cref="T:System.InvalidOperationException">There can only be one by-ref type and it must be the most outer (last) element wrapper.</exception>
            <exception cref="T:System.ObjectDisposedException">Tried to change this object after it's been completed.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IGenericReferencingBuilder.AddPointer">
            <summary>
            Add a pointer.
            </summary>
            <exception cref="T:System.InvalidOperationException">There can only be one by-ref type and it must be the most outer (last) element wrapper.</exception>
            <exception cref="T:System.ObjectDisposedException">Tried to change this object after it's been completed.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.IGenericReferencingBuilder.MakeByRef">
            <summary>
            Add a by-ref type wrapper. Must be done last.
            </summary>
            <exception cref="T:System.InvalidOperationException">There can only be one by-ref type and it must be the most outer (last) element wrapper.</exception>
            <exception cref="T:System.ObjectDisposedException">Tried to change this object after it's been completed.</exception>
        </member>
        <member name="T:DanielWillett.ReflectionTools.Formatting.IGenericReferencingParameterBuilder">
            <summary>
            Abstraction used for an object that creates a parameter which references a generic parameter of the method it's defined in.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.IGenericReferencingParameterBuilder.Name">
            <summary>
            Name of the parameter.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Tried to change this object after it's been completed.</exception>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.IGenericReferencingParameterBuilder.IsParams">
            <summary>
            Is this parameter a <see langword="params"/> (remainder) array?
            </summary>
            <exception cref="T:System.ObjectDisposedException">Tried to change this object after it's been completed.</exception>
        </member>
        <member name="T:DanielWillett.ReflectionTools.Formatting.IGenericReferencingReturnTypeBuilder">
            <summary>
            Abstraction used for an object that creates a return type which references a generic parameter of the method it's defined in.
            </summary>
        </member>
        <member name="T:DanielWillett.ReflectionTools.Formatting.GenericReferencingParameterBuilder">
            <summary>
            Builds a <see cref="T:DanielWillett.ReflectionTools.Formatting.MethodParameterDefinition"/> that references a generic parameter definition in a <see cref="T:DanielWillett.ReflectionTools.Formatting.MethodDefinition"/>.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.GenericReferencingParameterBuilder.GenericParameterIndex">
            <inheritdoc />
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.GenericReferencingParameterBuilder.Name">
            <inheritdoc />
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.GenericReferencingParameterBuilder.ByRefMode">
            <inheritdoc />
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.GenericReferencingParameterBuilder.IsParams">
            <inheritdoc />
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.GenericReferencingParameterBuilder.Depth">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.GenericReferencingParameterBuilder.#ctor(DanielWillett.ReflectionTools.Formatting.MethodDefinition,System.Int32,System.String,System.Boolean,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode)">
            <summary>
            Start a <see cref="T:DanielWillett.ReflectionTools.Formatting.GenericReferencingParameterBuilder"/> with the given generic parameter definition.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.GenericReferencingParameterBuilder.AddArray(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.GenericReferencingParameterBuilder.AddPointer">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.GenericReferencingParameterBuilder.MakeByRef">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.GenericReferencingParameterBuilder.CompleteGenericParameter">
            <exception cref="T:System.ObjectDisposedException">Tried to complete this parameter after it's already been completed.</exception>
        </member>
        <member name="T:DanielWillett.ReflectionTools.Formatting.GenericReferencingReturnTypeBuilder">
            <summary>
            Builds a return type that references a generic parameter definition in a <see cref="T:DanielWillett.ReflectionTools.Formatting.MethodDefinition"/>.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.GenericReferencingReturnTypeBuilder.GenericParameterIndex">
            <summary>
            Index in <see cref="P:DanielWillett.ReflectionTools.Formatting.MethodDefinition.GenericDefinitions"/> that this parameter references.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Tried to change this object after it's been completed.</exception>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.GenericReferencingReturnTypeBuilder.ByRefMode">
            <summary>
            What keyword to use for the by-ref return mode, if any.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Tried to change this object after it's been completed.</exception>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.GenericReferencingReturnTypeBuilder.Depth">
            <summary>
            Current number of types that are wrapped around the original element type.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.GenericReferencingReturnTypeBuilder.#ctor(DanielWillett.ReflectionTools.Formatting.MethodDefinition,System.Int32,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode)">
            <summary>
            Start a <see cref="T:DanielWillett.ReflectionTools.Formatting.GenericReferencingReturnTypeBuilder"/> with the given generic parameter definition.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.GenericReferencingReturnTypeBuilder.AddArray(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.GenericReferencingReturnTypeBuilder.AddPointer">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.GenericReferencingReturnTypeBuilder.MakeByRef">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.GenericReferencingReturnTypeBuilder.CompleteReturnType">
            <exception cref="T:System.ObjectDisposedException">Tried to complete this parameter after it's already been completed.</exception>
        </member>
        <member name="T:DanielWillett.ReflectionTools.Formatting.OpCodeFormattingContext">
            <summary>
            Defines how a set of an op code and operand formatting result will be used, which may influence formatting.
            </summary>
        </member>
        <member name="F:DanielWillett.ReflectionTools.Formatting.OpCodeFormattingContext.InLine">
            <summary>
            Used in-line in a log message, etc.
            </summary>
        </member>
        <member name="F:DanielWillett.ReflectionTools.Formatting.OpCodeFormattingContext.List">
            <summary>
            Used in a list of code instructions, i.e. listing all code instructions in a method. Each instruction will be put on a new line.
            </summary>
        </member>
        <member name="T:DanielWillett.ReflectionTools.Formatting.PropertyDefinition">
            <summary>
            Represents a shell of a property for formatting purposes.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.PropertyDefinition.IndexParameters">
            <summary>
            All parameters in the property if it's an indexer. <see langword="null"/> if no parameters are provided (making this property not an indexer).
            </summary>
            <remarks>Defaults to <see langword="null"/> (parameters not specified).</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.PropertyDefinition.Name">
            <summary>
            Name of the property.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.PropertyDefinition.DeclaringType">
            <summary>
            Type the property is declared in.
            </summary>
            <remarks>Defaults to <see langword="null"/>.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.PropertyDefinition.PropertyType">
            <summary>
            Type the property stores.
            </summary>
            <remarks>Defaults to <see langword="null"/>.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.PropertyDefinition.IsStatic">
            <summary>
            If the method requires an instance of <see cref="P:DanielWillett.ReflectionTools.Formatting.PropertyDefinition.DeclaringType"/> to be accessed.
            </summary>
            <remarks>Defaults to <see langword="false"/>.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.PropertyDefinition.HasGetter">
            <summary>
            If this property has a <see langword="get"/> accessor.
            </summary>
            <remarks>Defaults to <see langword="true"/>.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.PropertyDefinition.HasSetter">
            <summary>
            If this property has a <see langword="set"/> accessor.
            </summary>
            <remarks>Defaults to <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.PropertyDefinition.#ctor(System.String)">
            <summary>
            Create a property definition, starting with a property name.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.PropertyDefinition.FromProperty(System.Reflection.PropertyInfo)">
            <summary>
            Create a property definition from an existing property.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.PropertyDefinition.WithNoGetter">
            <summary>
            Specify that this property has no <see langword="get"/> accessor.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.PropertyDefinition.WithNoSetter">
            <summary>
            Specify that this property has no <see langword="set"/> accessor.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.PropertyDefinition.WithPropertyType``1">
            <summary>
            Set the type stored in the property.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.PropertyDefinition.WithPropertyType(System.Type)">
            <summary>
            Set the type stored in the property.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.PropertyDefinition.WithPropertyType(System.String)">
            <summary>
            Set the type stored in the property.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.PropertyDefinition.DeclaredIn``1(System.Boolean)">
            <summary>
            Set the declaring type of the property.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.PropertyDefinition.DeclaredIn(System.Type,System.Boolean)">
            <summary>
            Set the declaring type of the property.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.PropertyDefinition.DeclaredIn(System.String,System.Boolean)">
            <summary>
            Set the declaring type of the property.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.PropertyDefinition.WithParameter(DanielWillett.ReflectionTools.Formatting.MethodParameterDefinition@)">
            <summary>
            Add a parameter to the index parameter list.
            </summary>
            <exception cref="T:System.ArgumentException">Generic types are not supported in PropertyDefinitions.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.PropertyDefinition.WithParameter(System.Type,System.String)">
            <summary>
            Add a parameter to the index parameter list.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.PropertyDefinition.WithParameter(System.Type,System.String,System.Boolean)">
            <summary>
            Add a parameter to the index parameter list.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.PropertyDefinition.WithParameter(System.Type,System.String,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode)">
            <summary>
            Add a parameter to the index parameter list.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.PropertyDefinition.WithParameter(System.Type,System.String,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode,System.Boolean)">
            <summary>
            Add a parameter to the index parameter list.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.PropertyDefinition.WithParameter``1(System.String)">
            <summary>
            Add a parameter to the index parameter list.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.PropertyDefinition.WithParameter``1(System.String,System.Boolean)">
            <summary>
            Add a parameter to the index parameter list.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.PropertyDefinition.WithParameter``1(System.String,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode)">
            <summary>
            Add a parameter to the index parameter list.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.PropertyDefinition.WithParameter``1(System.String,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode,System.Boolean)">
            <summary>
            Add a parameter to the index parameter list.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.PropertyDefinition.WithParameter(System.String,System.String)">
            <summary>
            Add a parameter to the index parameter list.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.PropertyDefinition.WithParameter(System.String,System.String,System.Boolean)">
            <summary>
            Add a parameter to the index parameter list.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.PropertyDefinition.WithParameter(System.String,System.String,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode)">
            <summary>
            Add a parameter to the index parameter list.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.PropertyDefinition.WithParameter(System.String,System.String,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode,System.Boolean)">
            <summary>
            Add a parameter to the index parameter list.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.PropertyDefinition.GetFormatLength(DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.PropertyDefinition.Format(DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter,System.Span{System.Char})">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.PropertyDefinition.GetFormatLength(DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter,System.Boolean)">
            <summary>
            Calculate the length of the string returned by <see cref="M:DanielWillett.ReflectionTools.Formatting.PropertyDefinition.Format(DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter,System.Span{System.Char},System.Boolean)"/>.
            </summary>
            <param name="formatter">Instance of <see cref="T:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter"/> to use for the formatting.</param>
            <param name="includeAccessors">Should the accessors be put at the end.</param>
            <returns>The length in characters of this as a string.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.PropertyDefinition.Format(DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter,System.Span{System.Char},System.Boolean)">
            <summary>
            Format this into a string representation. Use <see cref="M:DanielWillett.ReflectionTools.Formatting.PropertyDefinition.GetFormatLength(DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter,System.Boolean)"/> to get the desired length of <paramref name="output"/>.
            </summary>
            <param name="output">Buffer to put the formatted characters in.</param>
            <param name="formatter">Instance of <see cref="T:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter"/> to use for the formatting.</param>
            <param name="includeAccessors">Should the accessors be put at the end.</param>
            <returns>The length in characters of this as a string that were written to <paramref name="output"/>.</returns>
            <exception cref="T:System.IndexOutOfRangeException"><paramref name="output"/> is not large enough.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.PropertyDefinition.Format(DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.PropertyDefinition.Format(DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter,System.Boolean)">
            <summary>
            Format this into a string representation.
            </summary>
            <param name="formatter">Instance of <see cref="T:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter"/> to use for the formatting.</param>
            <param name="includeAccessors">Should the accessors be put at the end.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.PropertyDefinition.ToString">
            <inheritdoc />
        </member>
        <member name="T:DanielWillett.ReflectionTools.Formatting.TypeDefinition">
            <summary>
            Represents a shell of a type for formatting purposes.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.TypeDefinition.Name">
            <summary>
            Name of the type.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.TypeDefinition.DeclaringType">
            <summary>
            Type the type is nested in.
            </summary>
            <remarks>Defaults to <see langword="null"/>.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.TypeDefinition.IsStatic">
            <summary>
            If the type is an <see langword="static"/> reference type.
            </summary>
            <remarks>Defaults to <see langword="false"/>. Will never be <see langword="true"/> if <see cref="P:DanielWillett.ReflectionTools.Formatting.TypeDefinition.IsValueType"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.TypeDefinition.IsReadOnly">
            <summary>
            If the type is a <see langword="readonly"/> value type.
            </summary>
            <remarks>Defaults to <see langword="false"/>. Will always be <see langword="false"/> if <see cref="P:DanielWillett.ReflectionTools.Formatting.TypeDefinition.IsValueType"/> is <see langword="false"/>.</remarks>
            <exception cref="T:System.InvalidOperationException">Can not create a read-only value type on a DelegateTypeBuilder.</exception>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.TypeDefinition.IsByRefLike">
            <summary>
            If the type is a <see langword="ref"/> value type.
            </summary>
            <remarks>Defaults to <see langword="false"/>. Will always be <see langword="false"/> if <see cref="P:DanielWillett.ReflectionTools.Formatting.TypeDefinition.IsValueType"/> is <see langword="false"/>.</remarks>
            <exception cref="T:System.InvalidOperationException">Can not create a by-ref-like value type on a DelegateTypeBuilder.</exception>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.TypeDefinition.IsEnum">
            <summary>
            If the type is an <see langword="enum"/> value type.
            </summary>
            <remarks>Defaults to <see langword="false"/>. Will always be <see langword="false"/> if <see cref="P:DanielWillett.ReflectionTools.Formatting.TypeDefinition.IsValueType"/> is <see langword="false"/>.</remarks>
            <exception cref="T:System.InvalidOperationException">Can not create an enum on a DelegateTypeBuilder.</exception>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.TypeDefinition.IsValueType">
            <summary>
            If the type is a value type <see langword="struct"/> instead of a reference type <see langword="class"/>.
            </summary>
            <remarks>Defaults to <see langword="false"/>. Will always be <see langword="true"/> if <see cref="P:DanielWillett.ReflectionTools.Formatting.TypeDefinition.IsEnum"/> or <see cref="P:DanielWillett.ReflectionTools.Formatting.TypeDefinition.IsReadOnly"/> is <see langword="true"/>.</remarks>
            <exception cref="T:System.InvalidOperationException">Can not create a value type on a DelegateTypeBuilder.</exception>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.TypeDefinition.IsInterface">
            <summary>
            If the type is an <see langword="static"/> reference type.
            </summary>
            <remarks>Defaults to <see langword="false"/>. Will never be <see langword="true"/> if <see cref="P:DanielWillett.ReflectionTools.Formatting.TypeDefinition.IsValueType"/> is <see langword="true"/>.</remarks>
            <exception cref="T:System.InvalidOperationException">Can not create an interface on a DelegateTypeBuilder.</exception>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.TypeDefinition.IsDelegate">
            <summary>
            If the type is a <see langword="delegate"/> reference type.
            </summary>
            <remarks>To create a delegate type, use <see cref="M:DanielWillett.ReflectionTools.Formatting.TypeDefinition.DefineDelegate(System.String)"/> or <see cref="M:DanielWillett.ReflectionTools.Formatting.TypeDefinition.FromDelegateType(System.Type,DanielWillett.ReflectionTools.IAccessor)"/>.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.TypeDefinition.ElementTypes">
            <summary>
            Array of int values defining how the type index is manipulated as an element type.
            <para>
            Element meanings:
            <code>
            <br/>* dim = -1 = pointer
            <br/>* dim &gt; 0  = array of rank {n}
            <br/>* dim &lt; -1 = -(int){ByRefTypeMode} - 1
            </code>
            </para>
            </summary>
            <remarks>Defaults to <see langword="null"/>.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.TypeDefinition.GenericDefinitions">
            <summary>
            All generic parameter definitions in the type. <see langword="null"/> if no definitions are provided. If this is a <see cref="T:DanielWillett.ReflectionTools.Formatting.DelegateTypeDefinition"/>, use <see cref="P:DanielWillett.ReflectionTools.Formatting.DelegateTypeDefinition.InvokeMethod"/> to define generic parameters.
            </summary>
            <remarks>Defaults to <see langword="null"/> (parameters not specified).</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.TypeDefinition.GenericParameters">
            <summary>
            All generic parameter values in the type. <see langword="null"/> if no generic parameter values are provided. If this is a <see cref="T:DanielWillett.ReflectionTools.Formatting.DelegateTypeDefinition"/>, use <see cref="P:DanielWillett.ReflectionTools.Formatting.DelegateTypeDefinition.InvokeMethod"/> to define generic parameters.
            </summary>
            <remarks>Defaults to <see langword="null"/> (parameters not specified).</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.TypeDefinition.#ctor(System.String)">
            <summary>
            Create a type definition, starting with a type name.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.TypeDefinition.DefineDelegate(System.String)">
            <summary>
            Creates a new <see cref="T:DanielWillett.ReflectionTools.Formatting.TypeDefinition"/> made for creating delegate types.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.TypeDefinition.FromType``1(DanielWillett.ReflectionTools.IAccessor)">
            <summary>
            Create a type definition from an existing type.
            </summary>
            <param name="accessor">Instance of <see cref="T:DanielWillett.ReflectionTools.IAccessor"/> to use, defaulting to <see cref="P:DanielWillett.ReflectionTools.Accessor.Active"/>.</param>
            <remarks>For <see langword="delegate"/> types, consider <see cref="M:DanielWillett.ReflectionTools.Formatting.TypeDefinition.FromDelegateType``1(DanielWillett.ReflectionTools.IAccessor)"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.TypeDefinition.FromType(System.Type,DanielWillett.ReflectionTools.IAccessor)">
            <summary>
            Create a type definition from an existing type.
            </summary>
            <param name="type">Type to model this <see cref="T:DanielWillett.ReflectionTools.Formatting.TypeDefinition"/> after.</param>
            <param name="accessor">Instance of <see cref="T:DanielWillett.ReflectionTools.IAccessor"/> to use, defaulting to <see cref="P:DanielWillett.ReflectionTools.Accessor.Active"/>.</param>
            <remarks>For <see langword="delegate"/> types, consider <see cref="M:DanielWillett.ReflectionTools.Formatting.TypeDefinition.FromDelegateType(System.Type,DanielWillett.ReflectionTools.IAccessor)"/>.</remarks>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.TypeDefinition.FromDelegateType``1(DanielWillett.ReflectionTools.IAccessor)">
            <summary>
            Create a type definition from an existing type.
            </summary>
            <param name="accessor">Instance of <see cref="T:DanielWillett.ReflectionTools.IAccessor"/> to use, defaulting to <see cref="P:DanielWillett.ReflectionTools.Accessor.Active"/>.</param>
            <exception cref="T:System.NotSupportedException">Reflection failure getting Invoke method from delegate type.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.TypeDefinition.FromDelegateType(System.Type,DanielWillett.ReflectionTools.IAccessor)">
            <summary>
            Create a type definition from an existing delegate type or element chain of types ending in a delegate type.
            </summary>
            <exception cref="T:System.ArgumentException">Type must be a delegate type.</exception>
            <exception cref="T:System.NotSupportedException">Reflection failure getting Invoke method from delegate type.</exception>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.TypeDefinition.AsReadOnlyValueType">
            <summary>
            Set <see cref="P:DanielWillett.ReflectionTools.Formatting.TypeDefinition.IsReadOnly"/> and <see cref="P:DanielWillett.ReflectionTools.Formatting.TypeDefinition.IsValueType"/> to <see langword="true"/>.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.TypeDefinition.AsByRefLikeValueType">
            <summary>
            Set <see cref="P:DanielWillett.ReflectionTools.Formatting.TypeDefinition.IsByRefLike"/> and <see cref="P:DanielWillett.ReflectionTools.Formatting.TypeDefinition.IsValueType"/> to <see langword="true"/>.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.TypeDefinition.AsEnum">
            <summary>
            Set <see cref="P:DanielWillett.ReflectionTools.Formatting.TypeDefinition.IsEnum"/> and <see cref="P:DanielWillett.ReflectionTools.Formatting.TypeDefinition.IsValueType"/> to <see langword="true"/>.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.TypeDefinition.NestedIn``1">
            <summary>
            Set the declaring type of the type.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.TypeDefinition.NestedIn(System.Type)">
            <summary>
            Set the declaring type of the type.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.TypeDefinition.NestedIn(System.String)">
            <summary>
            Set the declaring type of the type.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.TypeDefinition.WithGenericParameterDefinition(System.String)">
            <summary>
            Add a generic parameter definition to the generic definitions list.
            </summary>
            <exception cref="T:System.InvalidOperationException">Generic types should be defined in this delegate type's InvokeMethod instead.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.TypeDefinition.WithGenericParameterValue(System.Type)">
            <summary>
            Add a generic parameter value to the generic parameters list.
            </summary>
            <exception cref="T:System.InvalidOperationException">Generic types should be defined in this delegate type's InvokeMethod instead.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.TypeDefinition.WithGenericParameterValue``1">
            <summary>
            Add a generic parameter value to the generic parameters list.
            </summary>
            <exception cref="T:System.InvalidOperationException">Generic types should be defined in this delegate type's InvokeMethod instead.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.TypeDefinition.WithGenericParameterValue(System.String)">
            <summary>
            Add a generic parameter value to the generic parameters list.
            </summary>
            <exception cref="T:System.InvalidOperationException">Generic types should be defined in this delegate type's InvokeMethod instead.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.TypeDefinition.Array(System.Int32)">
            <summary>
            Add an array with the specified rank (dimension).
            </summary>
            <remarks>Keep in mind arrays of arrays are usually defined backwards so groups of sequential arrays should be defined as you would write it in C# (backwards).</remarks>
            <param name="rank">Number of dimensions the array has.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Rank must be 1 or higher.</exception>
            <exception cref="T:System.InvalidOperationException">There can only be one by-ref type and it must be the most outer (last) element wrapper.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.TypeDefinition.Pointer">
            <summary>
            Add a pointer.
            </summary>
            <exception cref="T:System.InvalidOperationException">There can only be one by-ref type and it must be the most outer (last) element wrapper.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.TypeDefinition.ByRefType">
            <summary>
            Add a by-ref type wrapper. Must be done last.
            </summary>
            <exception cref="T:System.InvalidOperationException">There can only be one by-ref type and it must be the most outer (last) element wrapper.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.TypeDefinition.GetFormatLength(DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.TypeDefinition.Format(DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter,System.Span{System.Char})">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.TypeDefinition.GetFormatLength(DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode)">
            <summary>
            Calculate the length of the string returned by <see cref="M:DanielWillett.ReflectionTools.Formatting.TypeDefinition.Format(DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter,System.Span{System.Char},DanielWillett.ReflectionTools.Formatting.ByRefTypeMode)"/>.
            </summary>
            <param name="formatter">Instance of <see cref="T:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter"/> to use for the formatting.</param>
            <param name="refMode">Describes the way a by-ref type is passed as a parameter.</param>
            <returns>The length in characters of this as a string.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.TypeDefinition.Format(DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter,System.Span{System.Char},DanielWillett.ReflectionTools.Formatting.ByRefTypeMode)">
            <summary>
            Format this into a string representation. Use <see cref="M:DanielWillett.ReflectionTools.Formatting.TypeDefinition.GetFormatLength(DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode)"/> to get the desired length of <paramref name="output"/>.
            </summary>
            <param name="output">Buffer to put the formatted characters in.</param>
            <param name="formatter">Instance of <see cref="T:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter"/> to use for the formatting.</param>
            <param name="refMode">Describes the way a by-ref type is passed as a parameter.</param>
            <returns>The length in characters of this as a string that were written to <paramref name="output"/>.</returns>
            <exception cref="T:System.IndexOutOfRangeException"><paramref name="output"/> is not large enough.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.TypeDefinition.Format(DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.TypeDefinition.Format(DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter,DanielWillett.ReflectionTools.Formatting.ByRefTypeMode)">
            <summary>
            Format this into a string representation.
            </summary>
            <param name="formatter">Instance of <see cref="T:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter"/> to use for the formatting.</param>
            <param name="refMode">Describes the way a by-ref type is passed as a parameter.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Formatting.TypeDefinition.ToString">
            <inheritdoc />
        </member>
        <member name="T:DanielWillett.ReflectionTools.Formatting.DelegateTypeDefinition">
            <summary>
            Represents a <see cref="T:DanielWillett.ReflectionTools.Formatting.TypeDefinition"/> for a delegate type.
            <para>
            Note that many properties and methods will throw an <see cref="T:System.InvalidOperationException"/> on this object, as denoted in the XML documentation.
            </para>
            </summary>
            <remarks>Create using <see cref="M:DanielWillett.ReflectionTools.Formatting.TypeDefinition.DefineDelegate(System.String)"/> or <see cref="M:DanielWillett.ReflectionTools.Formatting.TypeDefinition.FromDelegateType(System.Type,DanielWillett.ReflectionTools.IAccessor)"/>.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.Formatting.DelegateTypeDefinition.InvokeMethod">
            <summary>
            A <see cref="T:DanielWillett.ReflectionTools.Formatting.MethodDefinition"/> object used to define generic types and parameters.
            </summary>
            <remarks>Note that many properties and methods will throw an <see cref="T:System.InvalidOperationException"/> on this object, as denoted in the XML documentation.</remarks>
        </member>
        <member name="T:DanielWillett.ReflectionTools.IAccessor">
            <summary>
            Reflection utilities for accessing private or internal members. Interface for <see cref="T:DanielWillett.ReflectionTools.Accessor"/>.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.IAccessor.LogILTraceMessages">
            <summary>
            Should <see cref="P:DanielWillett.ReflectionTools.IAccessor.Logger"/> log generated IL code (as debug messages)?
            </summary>
            <remarks>Returns <see langword="false"/> if <see cref="P:DanielWillett.ReflectionTools.IAccessor.Logger"/> is <see langword="null"/>.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.IAccessor.LogDebugMessages">
            <summary>
            Should <see cref="P:DanielWillett.ReflectionTools.IAccessor.Logger"/> log debug messages?
            </summary>
            <remarks>Returns <see langword="false"/> if <see cref="P:DanielWillett.ReflectionTools.IAccessor.Logger"/> is <see langword="null"/>.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.IAccessor.LogInfoMessages">
            <summary>
            Should <see cref="P:DanielWillett.ReflectionTools.IAccessor.Logger"/> log info messages?
            </summary>
            <remarks>Returns <see langword="false"/> if <see cref="P:DanielWillett.ReflectionTools.IAccessor.Logger"/> is <see langword="null"/>.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.IAccessor.LogWarningMessages">
            <summary>
            Should <see cref="P:DanielWillett.ReflectionTools.IAccessor.Logger"/> log warning messages?
            </summary>
            <remarks>Returns <see langword="false"/> if <see cref="P:DanielWillett.ReflectionTools.IAccessor.Logger"/> is <see langword="null"/>.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.IAccessor.LogErrorMessages">
            <summary>
            Should <see cref="P:DanielWillett.ReflectionTools.IAccessor.Logger"/> log error messages?
            </summary>
            <remarks>Returns <see langword="false"/> if <see cref="P:DanielWillett.ReflectionTools.IAccessor.Logger"/> is <see langword="null"/>.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.IAccessor.Logger">
            <summary>
            Logging IO for all methods in library.
            <para>Assigning a value to will dispose the previous value if needed.</para>
            </summary>
            <remarks>Default value is an instance of <see cref="T:DanielWillett.ReflectionTools.ConsoleReflectionToolsLogger"/>, which outputs to <see cref="T:System.Console"/>.
            By assigning a value to this property, you transfer ownership of the object to this class, meaning it shouldn't be used or disposed outside this class at all.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.IAccessor.Formatter">
            <summary>
            Logging IO for all methods in library for standard output.
            <para>Assigning a value to will dispose the previous value if needed.</para>
            </summary>
            <remarks>Default value is an instance of <see cref="T:DanielWillett.ReflectionTools.ConsoleReflectionToolsLogger"/>, which outputs to <see cref="T:System.Console"/>.
            By assigning a value to this property, you transfer ownership of the object to this class, meaning it shouldn't be used or disposed outside this class at all.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.IAccessor.ExceptionFormatter">
            <summary>
            Logging IO for all methods in library for exceptions.
            <para>Assigning a value to will dispose the previous value if needed.</para>
            </summary>
            <remarks>Default value is an instance of <see cref="T:DanielWillett.ReflectionTools.ConsoleReflectionToolsLogger"/>, which outputs to <see cref="T:System.Console"/>.
            By assigning a value to this property, you transfer ownership of the object to this class, meaning it shouldn't be used or disposed outside this class at all.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.IAccessor.MSCoreLib">
            <summary>
            System primary assembly.
            </summary>
            <remarks>Lazily cached.</remarks>
            <exception cref="T:System.TypeLoadException"/>
        </member>
        <member name="P:DanielWillett.ReflectionTools.IAccessor.IsMono">
            <summary>
            Whether or not the <c>Mono.Runtime</c> class is available. Indicates if the current runtime is Mono.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GenerateInstanceSetter``2(System.String,System.Boolean)">
            <summary>
            Generates a dynamic method that sets an instance field value. For value types use <see cref="M:DanielWillett.ReflectionTools.IAccessor.GenerateInstanceSetter``1(System.Type,System.String,System.Boolean)"/> instead.
            </summary>
            <typeparam name="TInstance">Declaring type of the field.</typeparam>
            <typeparam name="TValue">Field return type.</typeparam>
            <param name="fieldName">Name of field that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GenerateInstanceSetter``2(System.Reflection.FieldInfo,System.Boolean)">
            <summary>
            Generates a dynamic method that sets an instance field value. For value types use <see cref="M:DanielWillett.ReflectionTools.IAccessor.GenerateInstanceSetter``1(System.Reflection.FieldInfo,System.Boolean)"/> instead.
            </summary>
            <typeparam name="TInstance">Declaring type of the field.</typeparam>
            <typeparam name="TValue">Field return type.</typeparam>
            <param name="field">Field that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GenerateInstanceSetter(System.Reflection.FieldInfo,System.Boolean)">
            <summary>
            Generates a dynamic method that sets an instance field value.
            </summary>
            <param name="field">Field that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
            <returns>A delegate of type <see cref="T:DanielWillett.ReflectionTools.InstanceSetter`2"/> with the generic arguments being the same as how they were defined in the field. If <paramref name="field"/>'s declaring type is a value type, <c>TInstance</c> will be <see cref="T:System.Object"/> instead of the declaring type to allow setting of value type fields via boxing.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GenerateInstanceGetter``2(System.String,System.Boolean)">
            <summary>
            Generates a dynamic method that gets an instance field value. Works for reference or value types.
            </summary>
            <typeparam name="TInstance">Declaring type of the field.</typeparam>
            <typeparam name="TValue">Field return type.</typeparam>
            <param name="fieldName">Name of field that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GenerateInstanceGetter``2(System.Reflection.FieldInfo,System.Boolean)">
            <summary>
            Generates a dynamic method that gets an instance field value. Works for reference or value types.
            </summary>
            <typeparam name="TInstance">Declaring type of the field.</typeparam>
            <typeparam name="TValue">Field return type.</typeparam>
            <param name="field">Field that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GenerateInstanceGetter(System.Reflection.FieldInfo,System.Boolean)">
            <summary>
            Generates a dynamic method that gets an instance field value. Works for reference or value types.
            </summary>
            <param name="field">Field that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <returns>A delegate of type <see cref="T:DanielWillett.ReflectionTools.InstanceGetter`2"/> with the generic arguments being the same as how they were defined in the field.</returns>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GenerateInstanceSetter``1(System.Type,System.String,System.Boolean)">
            <summary>
            Generates a dynamic method that sets an instance field value.
            When using value types, you have to store the value type in a boxed variable before passing it. This allows you to pass it as a reference type.<br/><br/>
            <code>
            object instance = new CustomStruct();
            SetField.Invoke(instance, 3);
            CustomStruct result = (CustomStruct)instance;
            </code>
            </summary>
            <param name="declaringType">Declaring type of the field.</param>
            <typeparam name="TValue">Field return type.</typeparam>
            <param name="fieldName">Name of field that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GenerateInstanceSetter``1(System.Reflection.FieldInfo,System.Boolean)">
            <summary>
            Generates a dynamic method that sets an instance field value.
            When using value types, you have to store the value type in a boxed variable before passing it. This allows you to pass it as a reference type.<br/><br/>
            <code>
            object instance = new CustomStruct();
            SetField.Invoke(instance, 3);
            CustomStruct result = (CustomStruct)instance;
            </code>
            </summary>
            <typeparam name="TValue">Field return type.</typeparam>
            <param name="field">Field that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GenerateInstanceGetter``1(System.Type,System.String,System.Boolean)">
            <summary>
            Generates a dynamic method that gets an instance field value. Works for reference or value types.
            </summary>
            <param name="declaringType">Declaring type of the field.</param>
            <typeparam name="TValue">Field return type.</typeparam>
            <param name="fieldName">Name of field that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GenerateInstanceGetter``1(System.Reflection.FieldInfo,System.Boolean)">
            <summary>
            Generates a dynamic method that gets an instance field value. Works for reference or value types.
            </summary>
            <typeparam name="TValue">Field return type.</typeparam>
            <param name="field">Field that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GenerateInstancePropertySetter``2(System.String,System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate that sets an instance property value. For value types use <see cref="M:DanielWillett.ReflectionTools.IAccessor.GenerateInstancePropertySetter``1(System.Type,System.String,System.Boolean,System.Boolean)"/> instead.
            </summary>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).
            This also must be <see langword="true"/> to not null-check instance methods of parameter-less reference types with a dynamic method.</param>
            <typeparam name="TInstance">Declaring type of the property.</typeparam>
            <typeparam name="TValue">Property return type.</typeparam>
            <param name="propertyName">Name of property that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GenerateInstancePropertyGetter``2(System.String,System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate that gets an instance property value. Works for reference or value types.
            </summary>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).
            This also must be <see langword="true"/> to not null-check instance methods of parameter-less reference types with a dynamic method.</param>
            <typeparam name="TInstance">Declaring type of the property.</typeparam>
            <typeparam name="TValue">Property return type.</typeparam>
            <param name="propertyName">Name of property that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GenerateInstancePropertySetter``2(System.Reflection.PropertyInfo,System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate that sets an instance property value. For value types use <see cref="M:DanielWillett.ReflectionTools.IAccessor.GenerateInstancePropertySetter``1(System.Reflection.PropertyInfo,System.Boolean,System.Boolean)"/> instead.
            </summary>
            <typeparam name="TInstance">Declaring type of the property.</typeparam>
            <typeparam name="TValue">Property return type.</typeparam>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).
            This also must be <see langword="true"/> to not null-check instance methods of parameter-less reference types with a dynamic method.</param>
            <param name="property">Property that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GenerateInstancePropertyGetter``2(System.Reflection.PropertyInfo,System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate that gets an instance property value. Works for reference or value types.
            </summary>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).
            This also must be <see langword="true"/> to not null-check instance methods of parameter-less reference types with a dynamic method.</param>
            <typeparam name="TInstance">Declaring type of the property.</typeparam>
            <typeparam name="TValue">Property return type.</typeparam>
            <param name="property">Property that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GenerateInstancePropertySetter(System.Reflection.PropertyInfo,System.Boolean)">
            <summary>
            Generates a delegate that sets an instance property value.
            </summary>
            <param name="property">Property that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <returns>A delegate of type <see cref="T:DanielWillett.ReflectionTools.InstanceSetter`2"/> with the generic arguments being the same as how they were defined in the field. If <paramref name="property"/>'s declaring type is a value type, <c>TInstance</c> will be <see cref="T:System.Object"/> instead of the declaring type to allow setting of value type fields via boxing.</returns>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GenerateInstancePropertyGetter(System.Reflection.PropertyInfo,System.Boolean)">
            <summary>
            Generates a delegate that gets an instance property value. Works for reference or value types.
            </summary>
            <param name="property">Property that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <returns>A delegate of type <see cref="T:DanielWillett.ReflectionTools.InstanceGetter`2"/> with the generic arguments being the same as how they were defined in the property.</returns>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GenerateInstancePropertySetter``1(System.Type,System.String,System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate if possible, otherwise a dynamic method, that sets an instance property value.
            When using value types, you have to store the value type in a boxed variable before passing it. This allows you to pass it as a reference type.<br/><br/>
            <code>
            object instance = new CustomStruct();
            SetProperty.Invoke(instance, 3);
            CustomStruct result = (CustomStruct)instance;
            </code>
            </summary>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).
            This also must be <see langword="true"/> to not null-check instance methods of parameter-less reference types with a dynamic method.</param>
            <param name="declaringType">Declaring type of the property.</param>
            <typeparam name="TValue">Property return type.</typeparam>
            <param name="propertyName">Name of property that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GenerateInstancePropertyGetter``1(System.Type,System.String,System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate if possible, otherwise a dynamic method, that gets an instance property value. Works for reference or value types.
            </summary>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).
            This also must be <see langword="true"/> to not null-check instance methods of parameter-less reference types with a dynamic method.</param>
            <param name="declaringType">Declaring type of the property.</param>
            <typeparam name="TValue">Property return type.</typeparam>
            <param name="propertyName">Name of property that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GenerateInstancePropertySetter``1(System.Reflection.PropertyInfo,System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate if possible, otherwise a dynamic method, that sets an instance property value.
            When using value types, you have to store the value type in a boxed variable before passing it. This allows you to pass it as a reference type.<br/><br/>
            <code>
            object instance = new CustomStruct();
            SetProperty.Invoke(instance, 3);
            CustomStruct result = (CustomStruct)instance;
            </code>
            </summary>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).
            This also must be <see langword="true"/> to not null-check instance methods of parameter-less reference types with a dynamic method.</param>
            <typeparam name="TValue">Property return type.</typeparam>
            <param name="property">Property that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GenerateInstancePropertyGetter``1(System.Reflection.PropertyInfo,System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate if possible, otherwise a dynamic method, that gets an instance property value. Works for reference or value types.
            </summary>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).
            This also must be <see langword="true"/> to not null-check instance methods of parameter-less reference types with a dynamic method.</param>
            <typeparam name="TValue">Property return type.</typeparam>
            <param name="property">Property that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GenerateStaticSetter``2(System.String,System.Boolean)">
            <summary>
            Generates a dynamic method that sets a static field value.
            </summary>
            <typeparam name="TDeclaringType">Declaring type of the field.</typeparam>
            <typeparam name="TValue">Field return type.</typeparam>
            <param name="fieldName">Name of the field that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GenerateStaticGetter``2(System.String,System.Boolean)">
            <summary>
            Generates a dynamic method that gets a static field value.
            </summary>
            <typeparam name="TDeclaringType">Declaring type of the field.</typeparam>
            <typeparam name="TValue">Field return type.</typeparam>
            <param name="fieldName">Name of the field that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GenerateStaticSetter``1(System.Type,System.String,System.Boolean)">
            <summary>
            Generates a dynamic method that sets a static field value.
            </summary>
            <param name="declaringType">Declaring type of the field.</param>
            <typeparam name="TValue">Field return type.</typeparam>
            <param name="fieldName">Name of the field that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GenerateStaticSetter``1(System.Reflection.FieldInfo,System.Boolean)">
            <summary>
            Generates a dynamic method that sets a static field value.
            </summary>
            <typeparam name="TValue">Field return type.</typeparam>
            <param name="field">Field that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GenerateStaticGetter``1(System.Type,System.String,System.Boolean)">
            <summary>
            Generates a dynamic method that gets a static field value.
            </summary>
            <param name="declaringType">Declaring type of the field.</param>
            <typeparam name="TValue">Field return type.</typeparam>
            <param name="fieldName">Name of the field that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GenerateStaticSetter(System.Reflection.FieldInfo,System.Boolean)">
            <summary>
            Generates a dynamic method that sets a static field value.
            </summary>
            <param name="field">Field that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <returns>A delegate of type <see cref="T:DanielWillett.ReflectionTools.StaticSetter`1"/> with the generic argument being the type of the field.</returns>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GenerateStaticGetter``1(System.Reflection.FieldInfo,System.Boolean)">
            <summary>
            Generates a dynamic method that gets a static field value.
            </summary>
            <typeparam name="TValue">Field return type.</typeparam>
            <param name="field">Field that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GenerateStaticGetter(System.Reflection.FieldInfo,System.Boolean)">
            <summary>
            Generates a dynamic method that gets a static field value.
            </summary>
            <param name="field">Field that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <returns>A delegate of type <see cref="T:DanielWillett.ReflectionTools.StaticGetter`1"/> with the generic argument being the type of the field.</returns>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GenerateStaticPropertySetter``2(System.String,System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate or dynamic method that sets a static property value.
            </summary>
            <typeparam name="TDeclaringType">Declaring type of the property.</typeparam>
            <typeparam name="TValue">Property return type.</typeparam>
            <param name="propertyName">Name of property that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).
            This also must be <see langword="true"/> to not null-check instance methods of parameter-less reference types with a dynamic method.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GenerateStaticPropertyGetter``2(System.String,System.Boolean)">
            <summary>
            Generates a delegate that gets a static property value.
            </summary>
            <typeparam name="TDeclaringType">Declaring type of the property.</typeparam>
            <typeparam name="TValue">Property return type.</typeparam>
            <param name="propertyName">Name of property that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GenerateStaticPropertyGetter``2(System.String,System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate that gets a static property value.
            </summary>
            <typeparam name="TDeclaringType">Declaring type of the property.</typeparam>
            <typeparam name="TValue">Property return type.</typeparam>
            <param name="propertyName">Name of property that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).
            This also must be <see langword="true"/> to not null-check instance methods of parameter-less reference types with a dynamic method.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GenerateStaticPropertySetter``1(System.Type,System.String,System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate or dynamic method that sets a static property value.
            </summary>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).
            This also must be <see langword="true"/> to not null-check instance methods of parameter-less reference types with a dynamic method.</param>
            <param name="declaringType">Declaring type of the property.</param>
            <typeparam name="TValue">Property return type.</typeparam>
            <param name="propertyName">Name of property that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GenerateStaticPropertyGetter``1(System.Type,System.String,System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate that gets a static property value.
            </summary>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).
            This also must be <see langword="true"/> to not null-check instance methods of parameter-less reference types with a dynamic method.</param>
            <param name="declaringType">Declaring type of the property.</param>
            <typeparam name="TValue">Property return type.</typeparam>
            <param name="propertyName">Name of property that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GenerateStaticPropertySetter``1(System.Reflection.PropertyInfo,System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate or dynamic method that sets a static property value.
            </summary>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).
            This also must be <see langword="true"/> to not null-check instance methods of parameter-less reference types with a dynamic method.</param>
            <typeparam name="TValue">Property return type.</typeparam>
            <param name="property">Property that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GenerateStaticPropertyGetter``1(System.Reflection.PropertyInfo,System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate that gets a static property value.
            </summary>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).
            This also must be <see langword="true"/> to not null-check instance methods of parameter-less reference types with a dynamic method.</param>
            <typeparam name="TValue">Property return type.</typeparam>
            <param name="property">Property that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GenerateStaticPropertySetter(System.Reflection.PropertyInfo,System.Boolean)">
            <summary>
            Generates a delegate or dynamic method that sets a static property value.
            </summary>
            <param name="property">Property that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <returns>A delegate of type <see cref="T:DanielWillett.ReflectionTools.StaticSetter`1"/> with the generic argument being the type of the property.</returns>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GenerateStaticPropertyGetter(System.Reflection.PropertyInfo,System.Boolean)">
            <summary>
            Generates a delegate that gets a static property value.
            </summary>
            <param name="property">Property that will be referenced.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <returns>A delegate of type <see cref="T:DanielWillett.ReflectionTools.StaticGetter`1"/> with the generic argument being the type of the property.</returns>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GenerateInstanceCaller``1(System.String,System.Type[],System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate or dynamic method that calls an instance method. For non-readonly methods with value types, the instance must be boxed (passed as <see cref="T:System.Object"/>) to keep any changes made.
            </summary>
            <remarks>The first parameter will be the instance.</remarks>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).
            This also must be <see langword="true"/> to not null-check instance methods of parameter-less reference types with a dynamic method.</param>
            <returns>A delegate of type <see cref="T:System.Action"/> or <see cref="T:System.Func`1"/> (or one of their generic counterparts), depending on the method signature. The first parameter will be the instance.</returns>
            <param name="methodName">Name of method that will be called.</param>
            <param name="parameters">Optional parameter list for resolving ambiguous methods.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GenerateInstanceCaller``2(System.String,System.Boolean,System.Boolean,System.Type[])">
            <summary>
            Generates a delegate or dynamic method that calls an instance method. For non-readonly methods with value types, the instance must be boxed (passed as <see cref="T:System.Object"/>) to keep any changes made.
            </summary>
            <remarks>The first parameter will be the instance.</remarks>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).
            This also must be <see langword="true"/> to not null-check instance methods of parameter-less reference types with a dynamic method.</param>
            <param name="methodName">Name of method that will be called.</param>
            <param name="parameters">Optional parameter list for resolving ambiguous methods.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GenerateInstanceCaller(System.Reflection.MethodInfo,System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate or dynamic method that calls an instance method. For non-readonly methods with value types, the instance must be boxed (passed as <see cref="T:System.Object"/>) to keep any changes made.
            </summary>
            <remarks>The first parameter will be the instance.</remarks>
            <returns>A delegate of type <see cref="T:System.Action"/> or <see cref="T:System.Func`1"/> (or one of their generic counterparts), depending on the method signature. The first parameter will be the instance.</returns>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).
            This also must be <see langword="true"/> to not null-check instance methods of parameter-less reference types with a dynamic method.</param>
            <param name="method">Method that will be called.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GenerateInstanceCaller``1(System.Reflection.MethodInfo,System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate or dynamic method that calls an instance method. For non-readonly methods with value types, the instance must be boxed (passed as <see cref="T:System.Object"/>) to keep any changes made.
            </summary>
            <remarks>The first parameter will be the instance.</remarks>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).
            This also must be <see langword="true"/> to not null-check instance methods of parameter-less reference types with a dynamic method.</param>
            <param name="method">Method that will be called.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GenerateInstanceCaller(System.Type,System.Reflection.MethodInfo,System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate or dynamic method that calls an instance method. For non-readonly methods with value types, the instance must be boxed (passed as <see cref="T:System.Object"/>) to keep any changes made.
            </summary>
            <remarks>The first parameter will be the instance.</remarks>
            <param name="delegateType">Type of delegate to return.</param>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).
            This also must be <see langword="true"/> to not null-check instance methods of parameter-less reference types with a dynamic method.</param>
            <param name="method">Method that will be called.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GenerateStaticCaller``1(System.String,System.Type[],System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate or dynamic method that calls a static method.
            </summary>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).</param>
            <returns>A delegate of type <see cref="T:System.Action"/> or <see cref="T:System.Func`1"/> (or one of their generic counterparts), depending on the method signature.</returns>
            <param name="methodName">Name of method that will be called.</param>
            <param name="parameters">Optional parameter list for resolving ambiguous methods.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GenerateStaticCaller``2(System.String,System.Boolean,System.Boolean,System.Type[])">
            <summary>
            Generates a delegate or dynamic method that calls a static method.
            </summary>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).</param>
            <param name="methodName">Name of method that will be called.</param>
            <param name="parameters">Optional parameter list for resolving ambiguous methods.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GenerateStaticCaller(System.Reflection.MethodInfo,System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate or dynamic method that calls a static method.
            </summary>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).</param>
            <returns>A delegate of type <see cref="T:System.Action"/> or <see cref="T:System.Func`1"/> (or one of their generic counterparts), depending on the method signature.</returns>
            <param name="method">Method that will be called.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GenerateStaticCaller``1(System.Reflection.MethodInfo,System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate or dynamic method that calls a static method.
            </summary>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).</param>
            <param name="method">Method that will be called.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GenerateStaticCaller(System.Type,System.Reflection.MethodInfo,System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate or dynamic method that calls a static method.
            </summary>
            <param name="delegateType">Type of delegate to return.</param>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).</param>
            <param name="method">Method that will be called.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GetDynamicMethodFlags(System.Boolean,System.Reflection.MethodAttributes@,System.Reflection.CallingConventions@)">
            <summary>
            Gets platform-specific flags for creating dynamic methods.
            </summary>
            <param name="static">Whether or not the method has no 'instance', only considered when on mono.</param>
            <param name="attributes">Method attributes to pass to <see cref="T:System.Reflection.Emit.DynamicMethod"/> constructor.</param>
            <param name="convention">Method convention to pass to <see cref="T:System.Reflection.Emit.DynamicMethod"/> constructor.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GetVisibility(System.Type)">
            <summary>
            Gets a simplified enum representing the visiblity (accessibility) of a <paramref name="type"/>.
            </summary>
            <remarks>Takes nested types into account, returning the lowest visibility in the nested hierarchy
            (ex. if an internal class is nested in a private nested type, method will consider it private).</remarks>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GetVisibility(System.Reflection.MethodBase)">
            <summary>
            Gets a simplified enum representing the visiblity (accessibility) of a <paramref name="method"/>.
            </summary>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GetVisibility(System.Reflection.FieldInfo)">
            <summary>
            Gets a simplified enum representing the visiblity (accessibility) of a <paramref name="field"/>.
            </summary>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GetVisibility(System.Reflection.PropertyInfo)">
            <summary>
            Gets a simplified enum representing the visiblity (accessibility) of a <paramref name="property"/>.
            </summary>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GetVisibility(System.Reflection.EventInfo)">
            <summary>
            Gets a simplified enum representing the visiblity (accessibility) of an <paramref name="event"/>.
            </summary>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GetHighestVisibility(System.Reflection.MethodBase,System.Reflection.MethodBase)">
            <summary>
            Get the highest visibilty needed for both of the given methods to be visible. Methods which are <see langword="null"/> are ignored.
            </summary>
            <remarks>Useful for getting property visiblity manually, will always be at least <see cref="F:DanielWillett.ReflectionTools.MemberVisibility.Private"/>.</remarks>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GetHighestVisibility(System.Reflection.MethodBase,System.Reflection.MethodBase,System.Reflection.MethodBase)">
            <summary>
            Get the highest visibilty needed for all three of the given methods to be visible. Methods which are <see langword="null"/> are ignored.
            </summary>
            <remarks>Useful for getting event visiblity manually, will always be at least <see cref="F:DanielWillett.ReflectionTools.MemberVisibility.Private"/>.</remarks>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GetHighestVisibility(System.Reflection.MethodBase[])">
            <summary>
            Get the highest visibilty needed for all of the given methods to be visible. Methods which are <see langword="null"/> are ignored.
            </summary>
            <remarks>Will always be at least <see cref="F:DanielWillett.ReflectionTools.MemberVisibility.Private"/>.</remarks>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.AssemblyGivesInternalAccess(System.Reflection.Assembly,System.String)">
            <summary>
            Checks if <paramref name="assembly"/> has a <see cref="T:System.Runtime.CompilerServices.InternalsVisibleToAttribute"/> with the given <paramref name="assemblyName"/>.
            The value of the attribute must match <paramref name="assemblyName"/> exactly.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.IsExtern(System.Reflection.MethodBase)">
            <summary>
            Checks <paramref name="method"/> for the <see langword="extern"/> flag.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.IsExtern(System.Reflection.FieldInfo)">
            <summary>
            Checks <paramref name="field"/> for the <see langword="extern"/> flag.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.IsExtern(System.Reflection.PropertyInfo,System.Boolean)">
            <summary>
            Checks <paramref name="property"/>'s getter and setter for the <see langword="extern"/> flag.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.IsDefinedSafe``1(System.Reflection.ICustomAttributeProvider,System.Boolean)">
            <summary>
            Checks for the the attribute of type <typeparamref name="TAttribute"/> on <paramref name="member"/>.
            </summary>
            <remarks>Alias of <see cref="M:DanielWillett.ReflectionTools.IAccessor.HasAttributeSafe``1(System.Reflection.ICustomAttributeProvider,System.Boolean)"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.IsDefinedSafe(System.Reflection.ICustomAttributeProvider,System.Type,System.Boolean)">
            <summary>
            Checks for the attribute of type <paramref name="attributeType"/> on <paramref name="member"/>.
            </summary>
            <remarks>Alias of <see cref="M:DanielWillett.ReflectionTools.IAccessor.HasAttributeSafe(System.Reflection.ICustomAttributeProvider,System.Type,System.Boolean)"/>.</remarks>
            <param name="member">Member to check for attributes. This can be <see cref="T:System.Reflection.Module"/>, <see cref="T:System.Reflection.Assembly"/>, <see cref="T:System.Reflection.MemberInfo"/>, or <see cref="T:System.Reflection.ParameterInfo"/>.</param>
            <param name="attributeType">Type of the attribute to check for.</param>
            <param name="inherit">Also check parent members.</param>
            <exception cref="T:System.ArgumentException"><paramref name="attributeType"/> did not derive from <see cref="T:System.Attribute"/>.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.IsCompilerAttributeDefinedSafe(System.Reflection.ICustomAttributeProvider,System.String,System.Boolean)">
            <summary>
            Checks for the attribute of type <c>System.Runtime.CompilerServices.<paramref name="typeName"/></c> on <paramref name="member"/>.
            </summary>
            <remarks>Alias of <see cref="M:DanielWillett.ReflectionTools.IAccessor.HasCompilerAttributeSafe(System.Reflection.ICustomAttributeProvider,System.String,System.Boolean)"/>. In some older versions of .NET Framework, attributes not available in the API at that version will be added to the assembly on compile. This checks for those.</remarks>
            <param name="member">Member to check for attributes. This can be <see cref="T:System.Reflection.Module"/>, <see cref="T:System.Reflection.Assembly"/>, <see cref="T:System.Reflection.MemberInfo"/>, or <see cref="T:System.Reflection.ParameterInfo"/>.</param>
            <param name="typeName">Type name of the attribute in <c>System.Runtime.CompilerServices</c> to check for.</param>
            <param name="inherit">Also check parent members.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.HasAttributeSafe``1(System.Reflection.ICustomAttributeProvider,System.Boolean)">
            <summary>
            Checks for the the attribute of type <typeparamref name="TAttribute"/> on <paramref name="member"/>.
            </summary>
            <remarks>Alias of <see cref="M:DanielWillett.ReflectionTools.IAccessor.IsDefinedSafe``1(System.Reflection.ICustomAttributeProvider,System.Boolean)"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.HasAttributeSafe(System.Reflection.ICustomAttributeProvider,System.Type,System.Boolean)">
            <summary>
            Checks for the attribute of type <paramref name="attributeType"/> on <paramref name="member"/>.
            </summary>
            <remarks>Alias of <see cref="M:DanielWillett.ReflectionTools.IAccessor.IsDefinedSafe(System.Reflection.ICustomAttributeProvider,System.Type,System.Boolean)"/>.</remarks>
            <param name="member">Member to check for attributes. This can be <see cref="T:System.Reflection.Module"/>, <see cref="T:System.Reflection.Assembly"/>, <see cref="T:System.Reflection.MemberInfo"/>, or <see cref="T:System.Reflection.ParameterInfo"/>.</param>
            <param name="attributeType">Type of the attribute to check for.</param>
            <param name="inherit">Also check parent members.</param>
            <exception cref="T:System.ArgumentException"><paramref name="attributeType"/> did not derive from <see cref="T:System.Attribute"/>.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.HasCompilerAttributeSafe(System.Reflection.ICustomAttributeProvider,System.String,System.Boolean)">
            <summary>
            Checks for the attribute of type <c>System.Runtime.CompilerServices.<paramref name="typeName"/></c> on <paramref name="member"/>.
            </summary>
            <remarks>Alias of <see cref="M:DanielWillett.ReflectionTools.IAccessor.IsCompilerAttributeDefinedSafe(System.Reflection.ICustomAttributeProvider,System.String,System.Boolean)"/>. In some older versions of .NET Framework, attributes not available in the API at that version will be added to the assembly on compile. This checks for those.</remarks>
            <param name="member">Member to check for attributes. This can be <see cref="T:System.Reflection.Module"/>, <see cref="T:System.Reflection.Assembly"/>, <see cref="T:System.Reflection.MemberInfo"/>, or <see cref="T:System.Reflection.ParameterInfo"/>.</param>
            <param name="typeName">Type name of the attribute in <c>System.Runtime.CompilerServices</c> to check for.</param>
            <param name="inherit">Also check parent members.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GetAttributeSafe``1(System.Reflection.ICustomAttributeProvider,System.Boolean)">
            <summary>
            Checks for and returns the the attribute of type <typeparamref name="TAttribute"/> on <paramref name="member"/>.
            </summary>
            <param name="inherit">Also check parent members.</param>
            <param name="member">Member to check for attributes. This can be <see cref="T:System.Reflection.Module"/>, <see cref="T:System.Reflection.Assembly"/>, <see cref="T:System.Reflection.MemberInfo"/>, or <see cref="T:System.Reflection.ParameterInfo"/>.</param>
            <typeparam name="TAttribute">Type of the attribute to check for.</typeparam>
            <exception cref="T:System.Reflection.AmbiguousMatchException">There are more than one attributes of type <typeparamref name="TAttribute"/>.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GetAttributeSafe(System.Reflection.ICustomAttributeProvider,System.Type,System.Boolean)">
            <summary>
            Checks for and returns the attribute of type <paramref name="attributeType"/> on <paramref name="member"/>.
            </summary>
            <param name="member">Member to check for attributes. This can be <see cref="T:System.Reflection.Module"/>, <see cref="T:System.Reflection.Assembly"/>, <see cref="T:System.Reflection.MemberInfo"/>, or <see cref="T:System.Reflection.ParameterInfo"/>.</param>
            <param name="attributeType">Type of the attribute to check for.</param>
            <param name="inherit">Also check parent members.</param>
            <exception cref="T:System.ArgumentException"><paramref name="attributeType"/> did not derive from <see cref="T:System.Attribute"/>.</exception>
            <exception cref="T:System.Reflection.AmbiguousMatchException">There are more than one attributes of type <paramref name="attributeType"/>.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GetAttributesSafe``1(System.Reflection.ICustomAttributeProvider,System.Boolean)">
            <summary>
            Checks for and returns the the attribute of type <typeparamref name="TAttribute"/> on <paramref name="member"/>.
            </summary>
            <param name="inherit">Also check parent members.</param>
            <param name="member">Member to check for attributes. This can be <see cref="T:System.Reflection.Module"/>, <see cref="T:System.Reflection.Assembly"/>, <see cref="T:System.Reflection.MemberInfo"/>, or <see cref="T:System.Reflection.ParameterInfo"/>.</param>
            <typeparam name="TAttribute">Type of the attribute to check for.</typeparam>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GetAttributesSafe(System.Reflection.ICustomAttributeProvider,System.Type,System.Boolean)">
            <summary>
            Checks for and returns the attribute of type <paramref name="attributeType"/> on <paramref name="member"/>.
            </summary>
            <param name="member">Member to check for attributes. This can be <see cref="T:System.Reflection.Module"/>, <see cref="T:System.Reflection.Assembly"/>, <see cref="T:System.Reflection.MemberInfo"/>, or <see cref="T:System.Reflection.ParameterInfo"/>.</param>
            <param name="attributeType">Type of the attribute to check for.</param>
            <param name="inherit">Also check parent members.</param>
            <exception cref="T:System.ArgumentException"><paramref name="attributeType"/> did not derive from <see cref="T:System.Attribute"/>.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.TryGetAttributeSafe``1(System.Reflection.ICustomAttributeProvider,``0@,System.Boolean)">
            <summary>
            Checks for and outputs the the attribute of type <typeparamref name="TAttribute"/> on <paramref name="member"/>.
            </summary>
            <param name="attribute">Found attribute, or <see langword="null"/> if it's not found (the function will return <see langword="false"/>).</param>
            <param name="inherit">Also check parent members.</param>
            <param name="member">Member to check for attributes. This can be <see cref="T:System.Reflection.Module"/>, <see cref="T:System.Reflection.Assembly"/>, <see cref="T:System.Reflection.MemberInfo"/>, or <see cref="T:System.Reflection.ParameterInfo"/>.</param>
            <typeparam name="TAttribute">Type of the attribute to check for.</typeparam>
            <returns><see langword="true"/> if the attribute was found, otherwise <see langword="false"/>.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.IsReadOnly(System.Reflection.ICustomAttributeProvider)">
            <summary>
            Checks for the <see cref="T:System.Runtime.CompilerServices.IsReadOnlyAttribute"/> on <paramref name="member"/>, which signifies the readonly value.
            <remarks>This behavior is overridden on fields to check <see cref="P:System.Reflection.FieldInfo.IsInitOnly"/>.</remarks>
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.IsByRefLikeType(System.Type)">
            <summary>
            Checks for the <see cref="T:System.Runtime.CompilerServices.IsByRefLikeAttribute"/> on <paramref name="type"/>, or <see cref="P:System.Type.IsByRefLike"/> on newer platforms.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.IsIgnored(System.Type)">
            <summary>
            Checks for the <see cref="T:DanielWillett.ReflectionTools.IgnoreAttribute"/> on <paramref name="type"/>.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.IsIgnored(System.Reflection.MemberInfo)">
            <summary>
            Checks for the <see cref="T:DanielWillett.ReflectionTools.IgnoreAttribute"/> on <paramref name="member"/>.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.IsIgnored(System.Reflection.Assembly)">
            <summary>
            Checks for the <see cref="T:DanielWillett.ReflectionTools.IgnoreAttribute"/> on <paramref name="assembly"/>.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.IsIgnored(System.Reflection.ParameterInfo)">
            <summary>
            Checks for the <see cref="T:DanielWillett.ReflectionTools.IgnoreAttribute"/> on <paramref name="parameter"/>.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.IsIgnored(System.Reflection.Module)">
            <summary>
            Checks for the <see cref="T:DanielWillett.ReflectionTools.IgnoreAttribute"/> on <paramref name="module"/>.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GetPriority(System.Type)">
            <summary>
            Checks for the <see cref="T:DanielWillett.ReflectionTools.PriorityAttribute"/> on <paramref name="type"/> and returns the priority (or zero if not found).
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GetPriority(System.Reflection.MemberInfo)">
            <summary>
            Checks for the <see cref="T:DanielWillett.ReflectionTools.PriorityAttribute"/> on <paramref name="member"/> and returns the priority (or zero if not found).
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GetPriority(System.Reflection.Assembly)">
            <summary>
            Checks for the <see cref="T:DanielWillett.ReflectionTools.PriorityAttribute"/> on <paramref name="assembly"/> and returns the priority (or zero if not found).
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GetPriority(System.Reflection.ParameterInfo)">
            <summary>
            Checks for the <see cref="T:DanielWillett.ReflectionTools.PriorityAttribute"/> on <paramref name="parameter"/> and returns the priority (or zero if not found).
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GetPriority(System.Reflection.Module)">
            <summary>
            Checks for the <see cref="T:DanielWillett.ReflectionTools.PriorityAttribute"/> on <paramref name="module"/> and returns the priority (or zero if not found).
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GetMethod(System.Delegate)">
            <summary>
            Safely gets the reflection method info of the passed method. Works best with static methods.<br/><br/>
            <code>
            MethodInfo? method = Accessor.GetMethod(Guid.Parse);
            </code>
            </summary>
            <returns>A method info of a passed delegate</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GetDefaultDelegate(System.Type,System.Collections.Generic.IList{System.Reflection.ParameterInfo},System.Type)">
            <param name="returnType">Return type of the method.</param>
            <param name="parameters">Method parameters, not including the instance.</param>
            <param name="instanceType">The declaring type, or <see langword="null"/> for static methods.</param>
            <remarks>The first argument will be the instance.</remarks>
            <returns>A delegate of type <see cref="T:System.Action"/> or <see cref="T:System.Func`1"/> (or one of their generic counterparts), depending on the method signature, or <see langword="null"/> if there are too many parameters.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.ForEachBaseType(System.Type,DanielWillett.ReflectionTools.ForEachBaseType,System.Boolean,System.Boolean)">
            <summary>
            Used to perform a repeated <paramref name="action"/> for each base type of a <paramref name="type"/>.
            </summary>
            <param name="type">Highest (most derived) type in the hierarchy.</param>
            <param name="action">Called optionally for <paramref name="type"/>, then for each base type in order from most related to least related.</param>
            <param name="includeParent">Call <paramref name="action"/> on <paramref name="type"/>. Overrides <paramref name="excludeSystemBase"/>.</param>
            <param name="excludeSystemBase">Excludes calling <paramref name="action"/> for <see cref="T:System.Object"/> or <see cref="T:System.ValueType"/>.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.ForEachBaseType(System.Type,DanielWillett.ReflectionTools.ForEachBaseTypeWhile,System.Boolean,System.Boolean)">
            <summary>
            Used to perform a repeated <paramref name="action"/> for each base type of a <paramref name="type"/>.
            </summary>
            <remarks>Execution can be broken by returning <see langword="false"/>.</remarks>
            <param name="type">Highest (most derived) type in the hierarchy.</param>
            <param name="action">Called optionally for <paramref name="type"/>, then for each base type in order from most related to least related.</param>
            <param name="includeParent">Call <paramref name="action"/> on <paramref name="type"/>. Overrides <paramref name="excludeSystemBase"/>.</param>
            <param name="excludeSystemBase">Excludes calling <paramref name="action"/> for <see cref="T:System.Object"/> or <see cref="T:System.ValueType"/>.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GetTypesSafe(System.Boolean)">
            <returns>Every type defined in the calling assembly.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GetTypesSafe(System.Reflection.Assembly,System.Boolean)">
            <returns>Every type defined in <paramref name="assembly"/>.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GetTypesSafe(System.Collections.Generic.IEnumerable{System.Reflection.Assembly},System.Boolean)">
            <returns>Every type defined in the provided <paramref name="assmeblies"/>.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GetImplementedMethod(System.Type,System.Reflection.MethodInfo)">
            <summary>
            Takes a method declared in an interface and returns an implementation on <paramref name="type"/>. Useful for getting explicit implementations.
            </summary>
            <exception cref="T:System.ArgumentException"><paramref name="interfaceMethod"/> is not defined in an interface or <paramref name="type"/> does not implement the interface it's defined in.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GetDelegateSignature``1(System.Type@,System.Reflection.ParameterInfo[]@)">
            <summary>
            Gets the (cached) <paramref name="returnType"/> and <paramref name="parameters"/> of a <typeparamref name="TDelegate"/> delegate type.
            </summary>
            <exception cref="T:System.NotSupportedException">Reflection failure.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GetDelegateSignature``1(System.Reflection.ParameterInfo@,System.Reflection.ParameterInfo[]@)">
            <summary>
            Gets the (cached) <paramref name="returnParameter"/> and <paramref name="parameters"/> of a <typeparamref name="TDelegate"/> delegate type.
            </summary>
            <exception cref="T:System.NotSupportedException">Reflection failure.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GetReturnType``1">
            <summary>
            Gets the (cached) return type of a <typeparamref name="TDelegate"/> delegate type.
            </summary>
            <exception cref="T:System.NotSupportedException">Reflection failure.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GetReturnParameter``1">
            <summary>
            Gets the (cached) return parameter info of a <typeparamref name="TDelegate"/> delegate type.
            </summary>
            <exception cref="T:System.NotSupportedException">Reflection failure.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GetParameters``1">
            <summary>
            Gets the (cached) parameters of a <typeparamref name="TDelegate"/> delegate type.
            </summary>
            <exception cref="T:System.NotSupportedException">Reflection failure.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GetInvokeMethod``1">
            <summary>
            Gets the (cached) <see langword="Invoke"/> method of a <typeparamref name="TDelegate"/> delegate type. All delegates have one by default.
            </summary>
            <exception cref="T:System.NotSupportedException">Reflection failure.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GetDelegateSignature(System.Type,System.Type@,System.Reflection.ParameterInfo[]@)">
            <summary>
            Gets the <paramref name="returnType"/> and <paramref name="parameters"/> of a <paramref name="delegateType"/>.
            </summary>
            <exception cref="T:System.NotSupportedException">Reflection failure.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GetDelegateSignature(System.Type,System.Reflection.ParameterInfo@,System.Reflection.ParameterInfo[]@)">
            <summary>
            Gets the <paramref name="returnParameter"/> and <paramref name="parameters"/> of a <paramref name="delegateType"/>.
            </summary>
            <exception cref="T:System.NotSupportedException">Reflection failure.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GetReturnType(System.Type)">
            <summary>
            Gets the return type of a <paramref name="delegateType"/>.
            </summary>
            <exception cref="T:System.NotSupportedException">Reflection failure.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="delegateType"/> is not a <see langword="delegate"/>.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GetReturnParameter(System.Type)">
            <summary>
            Gets the return parameter info of a <paramref name="delegateType"/>.
            </summary>
            <exception cref="T:System.NotSupportedException">Reflection failure.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="delegateType"/> is not a <see langword="delegate"/>.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GetParameters(System.Type)">
            <summary>
            Gets the parameters of a <paramref name="delegateType"/>.
            </summary>
            <exception cref="T:System.NotSupportedException">Reflection failure.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="delegateType"/> is not a <see langword="delegate"/>.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GetInvokeMethod(System.Type)">
            <summary>
            Gets the <see langword="Invoke"/> method of a <paramref name="delegateType"/>. All delegates have one by default.
            </summary>
            <exception cref="T:System.NotSupportedException">Reflection failure.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="delegateType"/> is not a <see langword="delegate"/>.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GetMemberType(System.Reflection.MemberInfo)">
            <summary>
            Get the 'type' of a member, returns <see cref="P:System.Reflection.FieldInfo.FieldType"/> or <see cref="P:System.Reflection.PropertyInfo.PropertyType"/> or
            <see cref="P:System.Reflection.MethodInfo.ReturnType"/> or <see cref="P:System.Reflection.EventInfo.EventHandlerType"/> or <see cref="P:System.Reflection.MemberInfo.DeclaringType"/> for constructors.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GetIsStatic(System.Reflection.MemberInfo)">
            <summary>
            Check any member for being static.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.ShouldCallvirt(System.Reflection.MethodBase)">
            <summary>
            Decide if a method should be callvirt'd instead of call'd. Usually you will use <see cref="M:DanielWillett.ReflectionTools.IAccessor.ShouldCallvirtRuntime(System.Reflection.MethodBase)"/> instead as it doesn't account for possible future keyword changes.
            </summary>
            <remarks>Note that not using call instead of callvirt may remove the check for a null instance.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.ShouldCallvirtRuntime(System.Reflection.MethodBase)">
            <summary>
            Decide if a method should be callvirt'd instead of call'd at runtime. Doesn't account for future changes.
            </summary>
            <remarks>Note that not using call instead of callvirt may remove the check for a null instance.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GetCall(System.Reflection.MethodBase)">
            <summary>
            Return the correct call <see cref="T:System.Reflection.Emit.OpCode"/> to use depending on the method. Usually you will use <see cref="M:DanielWillett.ReflectionTools.IAccessor.GetCallRuntime(System.Reflection.MethodBase)"/> instead as it doesn't account for possible future keyword changes.
            </summary>
            <remarks>Note that not using call instead of callvirt may remove the check for a null instance.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GetCallRuntime(System.Reflection.MethodBase)">
            <summary>
            Return the correct call <see cref="T:System.Reflection.Emit.OpCode"/> to use depending on the method at runtime. Doesn't account for future changes.
            </summary>
            <remarks>Note that not using call instead of callvirt may remove the check for a null instance.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GetUnderlyingArray``1(System.Collections.Generic.List{``0})">
            <summary>
            Get the underlying array from a list.
            </summary>
            <exception cref="T:System.NotSupportedException">Reflection failure.</exception>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GetUnderlyingArrayOrCopy``1(System.Collections.Generic.List{``0})">
            <summary>
            Get the underlying array from a list, or in the case of a reflection failure calls <see cref="M:System.Collections.Generic.List`1.ToArray"/> on <paramref name="list"/> and returns that.
            </summary>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.GetListVersion``1(System.Collections.Generic.List{``0})">
            <summary>
            Get the version of a list, which is incremented each time the list is updated.
            </summary>
            <exception cref="T:System.NotSupportedException">Reflection failure.</exception>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.SetUnderlyingArray``1(System.Collections.Generic.List{``0},``0[],System.Int32)">
            <summary>
            Set the size and underlying array of a list without any validation checks.
            </summary>
            <remarks>If used incorrectly this could corrupt a list.</remarks>
            <exception cref="T:System.NotSupportedException">Reflection failure.</exception>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.TryGetUnderlyingArray``1(System.Collections.Generic.List{``0},``0[]@)">
            <summary>
            Get the underlying array from a list.
            </summary>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.TryGetListVersion``1(System.Collections.Generic.List{``0},System.Int32@)">
            <summary>
            Get the version of a list, which is incremented each time the list is updated.
            </summary>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.TrySetUnderlyingArray``1(System.Collections.Generic.List{``0},``0[],System.Int32)">
            <summary>
            Set the size and underlying array of a list without any validation checks.
            </summary>
            <remarks>If used incorrectly this could corrupt a list.</remarks>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.CouldBeAssignedTo(System.Type,System.Type)">
            <summary>
            Checks if it's possible for a variable of type <paramref name="actualType"/> to have a value of type <paramref name="queriedType"/>. 
            </summary>
            <returns><see langword="true"/> if <paramref name="actualType"/> is assignable from <paramref name="queriedType"/> or if <paramref name="queriedType"/> is assignable from <paramref name="actualType"/>.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.CouldBeAssignedTo``1(System.Type)">
            <summary>
            Checks if it's possible for a variable of type <paramref name="actualType"/> to have a value of type <typeparamref name="T"/>. 
            </summary>
            <returns><see langword="true"/> if <paramref name="actualType"/> is assignable from <typeparamref name="T"/> or if <typeparamref name="T"/> is assignable from <paramref name="actualType"/>.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.AsEmitter(System.Reflection.Emit.ILGenerator,System.Boolean,System.Boolean)">
            <summary>
            Nethod to get a <see cref="T:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter"/> from an existing <see cref="T:System.Reflection.Emit.ILGenerator"/>.
            </summary>
            <param name="generator"><see cref="T:System.Reflection.Emit.ILGenerator"/> to wrap.</param>
            <param name="debuggable">Shows debug logging as the method generates.</param>
            <param name="addBreakpoints">Shows debug logging as the method executes.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.AsEmitter(System.Reflection.Emit.DynamicMethod,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Method to get a <see cref="T:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter"/> from an existing <see cref="T:System.Reflection.Emit.DynamicMethod"/>.
            </summary>
            <param name="dynMethod">Dynamic method.</param>
            <param name="debuggable">Shows debug logging as the method generates.</param>
            <param name="addBreakpoints">Shows debug logging as the method executes.</param>
            <param name="streamSize">The size of the MSIL stream, in bytes.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.AsEmitter(System.Reflection.Emit.MethodBuilder,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Method to get a <see cref="T:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter"/> from an existing <see cref="T:System.Reflection.Emit.MethodBuilder"/>.
            </summary>
            <param name="methodBuilder">Dynamic method builder.</param>
            <param name="debuggable">Shows debug logging as the method generates.</param>
            <param name="addBreakpoints">Shows debug logging as the method executes.</param>
            <param name="streamSize">The size of the MSIL stream, in bytes.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.AsEmitter(System.Reflection.Emit.ConstructorBuilder,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Method to get a <see cref="T:DanielWillett.ReflectionTools.Emit.IOpCodeEmitter"/> from an existing <see cref="T:System.Reflection.Emit.ConstructorBuilder"/>.
            </summary>
            <param name="constructorBuilder">Dynamic constructor builder.</param>
            <param name="debuggable">Shows debug logging as the constructor generates.</param>
            <param name="addBreakpoints">Shows debug logging as the constructor executes.</param>
            <param name="streamSize">The size of the MSIL stream, in bytes.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.AsVariable(System.Reflection.FieldInfo)">
            <summary>
            Creates an abstracted <see cref="T:DanielWillett.ReflectionTools.IVariable"/> for <paramref name="field"/>.
            </summary>
            <param name="field">The underlying field.</param>
            <returns>An abstracted variable with <paramref name="field"/> as it's underlying field.</returns>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.AsVariable(System.Reflection.PropertyInfo)">
            <summary>
            Creates an abstracted <see cref="T:DanielWillett.ReflectionTools.IVariable"/> for <paramref name="property"/>.
            </summary>
            <param name="property">The underlying property.</param>
            <returns>An abstracted variable with <paramref name="property"/> as it's underlying property.</returns>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.AsVariable(System.Reflection.MemberInfo)">
            <summary>
            Creates an abstracted <see cref="T:DanielWillett.ReflectionTools.IVariable"/> for <paramref name="member"/>, a field or property.
            </summary>
            <param name="member">The underlying field or property. Must be of type <see cref="T:System.Reflection.FieldInfo"/> or <see cref="T:System.Reflection.PropertyInfo"/>.</param>
            <returns>An abstracted variable with <paramref name="member"/> as it's underlying field or property.</returns>
            <exception cref="T:System.ArgumentNullException"/>
            <exception cref="T:System.ArgumentException"><paramref name="member"/> is not a field or property.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.AsStaticVariable``1(System.Reflection.FieldInfo)">
            <summary>
            Creates a static, strongly-typed, abstracted <see cref="T:DanielWillett.ReflectionTools.IVariable"/> for <paramref name="field"/>.
            </summary>
            <param name="field">The underlying field.</param>
            <typeparam name="TMemberType">The field type of <paramref name="field"/>.</typeparam>
            <returns>An abstracted variable with <paramref name="field"/> as it's underlying field.</returns>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.AsStaticVariable``1(System.Reflection.PropertyInfo)">
            <summary>
            Creates a static, strongly-typed, abstracted <see cref="T:DanielWillett.ReflectionTools.IVariable"/> for <paramref name="property"/>.
            </summary>
            <param name="property">The underlying property.</param>
            <typeparam name="TMemberType">The property type of <paramref name="property"/>.</typeparam>
            <returns>An abstracted variable with <paramref name="property"/> as it's underlying property.</returns>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.AsInstanceVariable``2(System.Reflection.FieldInfo)">
            <summary>
            Creates an instance, strongly-typed, abstracted <see cref="T:DanielWillett.ReflectionTools.IVariable"/> for <paramref name="field"/>.
            </summary>
            <param name="field">The underlying field.</param>
            <typeparam name="TMemberType">The field type of <paramref name="field"/>.</typeparam>
            <typeparam name="TDeclaringType">The type that <paramref name="field"/> is declared in.</typeparam>
            <returns>An abstracted variable with <paramref name="field"/> as it's underlying field.</returns>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.AsInstanceVariable``2(System.Reflection.PropertyInfo)">
            <summary>
            Creates an instance, strongly-typed, abstracted <see cref="T:DanielWillett.ReflectionTools.IVariable"/> for <paramref name="property"/>.
            </summary>
            <param name="property">The underlying property.</param>
            <typeparam name="TMemberType">The property type of <paramref name="property"/>.</typeparam>
            <typeparam name="TDeclaringType">The type that <paramref name="property"/> is declared in.</typeparam>
            <returns>An abstracted variable with <paramref name="property"/> as it's underlying property.</returns>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.TryFind``1(System.String,DanielWillett.ReflectionTools.IVariable@,System.Boolean)">
            <summary>
            Find a variable by declaring type and name.
            </summary>
            <param name="name">Exact name of the field or property.</param>
            <param name="ignoreCase">Whether or not to perform a case-insensitive search.</param>
            <param name="variable">The found variable, or <see langword="null"/>.</param>
            <typeparam name="TDeclaringType">Type which declares the member, or a type up the hierarchy of a type that declares the member.</typeparam>
            <returns><see langword="true"/> if the variable was found, otherwise <see langword="false"/>.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.TryFind(System.Type,System.String,DanielWillett.ReflectionTools.IVariable@,System.Boolean)">
            <summary>
            Find a variable by declaring type and name.
            </summary>
            <param name="declaringType">Type which declares the member, or a type up the hierarchy of a type that declares the member.</param>
            <param name="name">Exact name of the field or property.</param>
            <param name="variable">The found variable, or <see langword="null"/>.</param>
            <param name="ignoreCase">Whether or not to perform a case-insensitive search.</param>
            <returns><see langword="true"/> if the variable was found, otherwise <see langword="false"/>.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.TryFindStatic``2(System.String,DanielWillett.ReflectionTools.IStaticVariable{``1}@,System.Boolean)">
            <summary>
            Find a variable by declaring type and name.
            </summary>
            <param name="name">Exact name of the field or property.</param>
            <param name="ignoreCase">Whether or not to perform a case-insensitive search.</param>
            <param name="variable">The found variable, or <see langword="null"/>.</param>
            <typeparam name="TMemberType">The type of the field or property.</typeparam>
            <typeparam name="TDeclaringType">Type which declares the member, or a type up the hierarchy of a type that declares the member.</typeparam>
            <returns><see langword="true"/> if the variable was found, otherwise <see langword="false"/>.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.TryFindStatic``1(System.Type,System.String,DanielWillett.ReflectionTools.IStaticVariable{``0}@,System.Boolean)">
            <summary>
            Find a variable by declaring type and name.
            </summary>
            <param name="name">Exact name of the field or property.</param>
            <param name="ignoreCase">Whether or not to perform a case-insensitive search.</param>
            <param name="variable">The found variable, or <see langword="null"/>.</param>
            <param name="declaringType">Type which declares the member, or a type up the hierarchy of a type that declares the member.</param>
            <typeparam name="TMemberType">The type of the field or property.</typeparam>
            <returns><see langword="true"/> if the variable was found, otherwise <see langword="false"/>.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.Find``1(System.String,System.Boolean)">
            <summary>
            Find a variable by declaring type and name.
            </summary>
            <param name="name">Exact name of the field or property.</param>
            <param name="ignoreCase">Whether or not to perform a case-insensitive search.</param>
            <typeparam name="TDeclaringType">Type which declares the member, or a type up the hierarchy of a type that declares the member.</typeparam>
            <returns>The found variable, or <see langword="null"/>.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.FindStatic``2(System.String,System.Boolean)">
            <summary>
            Find a variable by declaring type and name.
            </summary>
            <param name="name">Exact name of the field or property.</param>
            <param name="ignoreCase">Whether or not to perform a case-insensitive search.</param>
            <typeparam name="TDeclaringType">Type which declares the member, or a type up the hierarchy of a type that declares the member.</typeparam>
            <typeparam name="TMemberType">The type of the field or property.</typeparam>
            <returns>The found variable, or <see langword="null"/>.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.Find(System.Type,System.String,System.Boolean)">
            <summary>
            Find a variable by declaring type and name.
            </summary>
            <param name="declaringType">Type which declares the member, or a type up the hierarchy of a type that declares the member.</param>
            <param name="name">Exact name of the field or property.</param>
            <param name="ignoreCase">Whether or not to perform a case-insensitive search.</param>
            <returns>The found variable, or <see langword="null"/>.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.FindStatic``1(System.Type,System.String,System.Boolean)">
            <summary>
            Find a static variable by declaring type and name.
            </summary>
            <typeparam name="TMemberType">The type of the field or property.</typeparam>
            <param name="declaringType">Type which declares the member, or a type up the hierarchy of a type that declares the member.</param>
            <param name="name">Exact name of the field or property.</param>
            <param name="ignoreCase">Whether or not to perform a case-insensitive search.</param>
            <returns>The found variable, or <see langword="null"/>.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IAccessor.FindInstance``2(System.String,System.Boolean)">
            <summary>
            Find an instance variable by declaring type and name.
            </summary>
            <typeparam name="TMemberType">The type of the field or property.</typeparam>
            <typeparam name="TDeclaringType">Type which declares the member, or a type up the hierarchy of a type that declares the member.</typeparam>
            <param name="name">Exact name of the field or property.</param>
            <param name="ignoreCase">Whether or not to perform a case-insensitive search.</param>
            <returns>The found variable, or <see langword="null"/>.</returns>
        </member>
        <member name="T:DanielWillett.ReflectionTools.IgnoreAttribute">
            <summary>
            Ignore members from being checked by reflection (where supported).
            </summary>
        </member>
        <member name="T:DanielWillett.ReflectionTools.IoC.DependencyInjectionExtensions">
            <summary>
            Extensions for adding ReflectionTools to a service provider.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IoC.DependencyInjectionExtensions.AddReflectionTools(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Action{DanielWillett.ReflectionTools.IAccessor},System.Boolean)">
            <summary>
            Add <see cref="T:DanielWillett.ReflectionTools.IAccessor"/> as a service with logging.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IoC.DependencyInjectionExtensions.AddReflectionTools``2(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Action{DanielWillett.ReflectionTools.IAccessor},System.Boolean)">
            <summary>
            Add <see cref="T:DanielWillett.ReflectionTools.IAccessor"/> as a service with logging and the specified formatters.
            </summary>
        </member>
        <member name="T:DanielWillett.ReflectionTools.IoC.LoggerFactoryExtensions">
            <summary>
            Provides extension methods for <see cref="T:Microsoft.Extensions.Logging.ILoggerFactory"/>.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IoC.LoggerFactoryExtensions.CreateReflectionToolsLogger(Microsoft.Extensions.Logging.ILoggerFactory,System.Boolean)">
            <summary>
            Creates a logger proxy for <see cref="P:DanielWillett.ReflectionTools.IAccessor.Logger"/>
            </summary>
            <param name="disposeFactoryOnDispose">Should <paramref name="loggerFactory"/> be disposed when this object gets disposed?</param>
            <param name="loggerFactory">Factory to create loggers from.</param>
        </member>
        <member name="T:DanielWillett.ReflectionTools.IReflectionToolsLogger">
            <summary>
            Trace and error logger for any reflection tools.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IReflectionToolsLogger.LogDebug(System.String,System.String)">
            <summary>
            Logs a verbose message meant for debugging.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IReflectionToolsLogger.LogInfo(System.String,System.String)">
            <summary>
            Logs information that may be useful.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IReflectionToolsLogger.LogWarning(System.String,System.String)">
            <summary>
            Logs warnings that could cause errors but may be okay.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IReflectionToolsLogger.LogError(System.String,System.Exception,System.String)">
            <summary>
            Logs errors and/or <see cref="T:System.Exception"/>s.
            </summary>
        </member>
        <member name="T:DanielWillett.ReflectionTools.ReflectionToolsLoggerProxy">
            <summary>
            Implement a <see cref="T:Microsoft.Extensions.Logging.ILogger"/> through <see cref="T:DanielWillett.ReflectionTools.IReflectionToolsLogger"/>.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.ReflectionToolsLoggerProxy.LoggerFactory">
            <summary>
            Factory to create loggers from.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.ReflectionToolsLoggerProxy.DisposeFactoryOnDispose">
            <summary>
            Should <see cref="P:DanielWillett.ReflectionTools.ReflectionToolsLoggerProxy.LoggerFactory"/> be disposed when this object gets disposed?
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.ReflectionToolsLoggerProxy.#ctor(Microsoft.Extensions.Logging.ILoggerFactory)">
            <summary>
            Creates a proxy to implement <see cref="T:DanielWillett.ReflectionTools.IReflectionToolsLogger"/> with <see cref="T:Microsoft.Extensions.Logging.ILogger"/>.
            </summary>
            <param name="loggerFactory">Factory to create loggers from.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.ReflectionToolsLoggerProxy.#ctor(Microsoft.Extensions.Logging.ILoggerFactory,System.Boolean)">
            <summary>
            Creates a proxy to implement <see cref="T:DanielWillett.ReflectionTools.IReflectionToolsLogger"/> with <see cref="T:Microsoft.Extensions.Logging.ILogger"/>.
            </summary>
            <param name="disposeFactoryOnDispose">Should <see cref="P:DanielWillett.ReflectionTools.ReflectionToolsLoggerProxy.LoggerFactory"/> be disposed when this object gets disposed?</param>
            <param name="loggerFactory">Factory to create loggers from.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.ReflectionToolsLoggerProxy.LogDebug(System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.ReflectionToolsLoggerProxy.LogInfo(System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.ReflectionToolsLoggerProxy.LogWarning(System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.ReflectionToolsLoggerProxy.LogError(System.String,System.Exception,System.String)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.ReflectionToolsLoggerProxy.Dispose">
            <inheritdoc />
        </member>
        <member name="T:DanielWillett.ReflectionTools.ConsoleReflectionToolsLogger">
            <summary>
            Logs messages to the <see cref="T:System.Console"/>.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.ConsoleReflectionToolsLogger.DebugColor">
            <summary>
            Color of debug messages in the console.
            </summary>
            <remarks>Default value: <see cref="F:System.ConsoleColor.DarkGray"/>.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.ConsoleReflectionToolsLogger.InfoColor">
            <summary>
            Color of info messages in the console.
            </summary>
            <remarks>Default value: <see cref="F:System.ConsoleColor.Gray"/>.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.ConsoleReflectionToolsLogger.WarningColor">
            <summary>
            Color of warning messages in the console.
            </summary>
            <remarks>Default value: <see cref="F:System.ConsoleColor.Yellow"/>.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.ConsoleReflectionToolsLogger.ErrorColor">
            <summary>
            Color of error messages in the console.
            </summary>
            <remarks>Default value: <see cref="F:System.ConsoleColor.Red"/>.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.ConsoleReflectionToolsLogger.LogErrorStackTrace">
            <summary>
            Should stack traces be logged for errors. Stack traces are always logged for exceptions.
            </summary>
            <remarks>Default value: <see langword="false"/>.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.ConsoleReflectionToolsLogger.LogWarningStackTrace">
            <summary>
            Should stack traces be logged for warnings.
            </summary>
            <remarks>Default value: <see langword="false"/>.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.ConsoleReflectionToolsLogger.LogInfoStackTrace">
            <summary>
            Should stack traces be logged for info messages.
            </summary>
            <remarks>Default value: <see langword="false"/>.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.ConsoleReflectionToolsLogger.LogDebugStackTrace">
            <summary>
            Should stack traces be logged for debug messages.
            </summary>
            <remarks>Default value: <see langword="false"/>.</remarks>
        </member>
        <member name="M:DanielWillett.ReflectionTools.ConsoleReflectionToolsLogger.LogDebug(System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.ConsoleReflectionToolsLogger.LogInfo(System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.ConsoleReflectionToolsLogger.LogWarning(System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:DanielWillett.ReflectionTools.ConsoleReflectionToolsLogger.LogError(System.String,System.Exception,System.String)">
            <inheritdoc />
        </member>
        <member name="T:DanielWillett.ReflectionTools.MemberVisibility">
            <summary>
            Simplified enumeration for defining member visibilities (accessibility levels).
            </summary>
        </member>
        <member name="F:DanielWillett.ReflectionTools.MemberVisibility.Unknown">
            <summary>
            Unknown visibility, usually meaning an invalid member definition.
            </summary>
        </member>
        <member name="F:DanielWillett.ReflectionTools.MemberVisibility.Private">
            <summary>
            Accessible only to the declaring type and it's nested types.
            </summary>
            <remarks>Designated <see langword="Private"/> in the CLR.</remarks>
        </member>
        <member name="F:DanielWillett.ReflectionTools.MemberVisibility.PrivateProtected">
            <summary>
            Accessible to all types deriving from the declaring type or types nested within those types
            that are also within the defining assembly (or within assemblies that have been given access with the <see cref="T:System.Runtime.CompilerServices.InternalsVisibleToAttribute"/>).
            </summary>
            <remarks>Designated <see langword="FamANDAssem"/> in the CLR.</remarks>
        </member>
        <member name="F:DanielWillett.ReflectionTools.MemberVisibility.Protected">
            <summary>
            Accessible to all types deriving from the declaring type or types nested within those types.
            </summary>
            <remarks>Designated <see langword="Family"/> in the CLR.</remarks>
        </member>
        <member name="F:DanielWillett.ReflectionTools.MemberVisibility.ProtectedInternal">
            <summary>
            Accessible to all types deriving from the declaring type or types nested within those types,
            or within the defining assembly (or within assemblies that have been given access with the <see cref="T:System.Runtime.CompilerServices.InternalsVisibleToAttribute"/>).
            </summary>
            <remarks>Designated <see langword="FamORAssem"/> in the CLR.</remarks>
        </member>
        <member name="F:DanielWillett.ReflectionTools.MemberVisibility.Internal">
            <summary>
            Accessible to all types within the defining assembly (or within assemblies that have been given access with the <see cref="T:System.Runtime.CompilerServices.InternalsVisibleToAttribute"/>).
            </summary>
            <remarks>Designated <see langword="Assembly"/> in the CLR.</remarks>
        </member>
        <member name="F:DanielWillett.ReflectionTools.MemberVisibility.Public">
            <summary>
            Accessible to all types.
            </summary>
            <remarks>Designated <see langword="Public"/> in the CLR.</remarks>
        </member>
        <member name="T:DanielWillett.ReflectionTools.PriorityAttribute">
            <summary>
            Order members highest to lowest (where supported).
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.PriorityAttribute.Priority">
            <summary>
            Higher numbers come before lower numbers. Zero is neutral.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.PriorityAttribute.#ctor(System.Int32)">
            <summary>
            Set the priority of a member.
            </summary>
            <param name="priority">Higher numbers come before lower numbers. Zero is neutral.</param>
        </member>
        <member name="T:DanielWillett.ReflectionTools.StopwatchExtensions">
            <summary>
            Provides extension methods for <see cref="T:System.Diagnostics.Stopwatch"/>.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.StopwatchExtensions.GetElapsedMilliseconds(System.Diagnostics.Stopwatch)">
            <summary>
            Gets the amount of milliseconds elapsed from a <see cref="T:System.Diagnostics.Stopwatch"/> as a decimal instead of an integer.
            </summary>
        </member>
        <member name="T:DanielWillett.ReflectionTools.InstanceFieldVariable`2">
            <summary>
            See <see cref="M:DanielWillett.ReflectionTools.Variables.AsInstanceVariable``2(System.Reflection.FieldInfo,DanielWillett.ReflectionTools.IAccessor)"/>.
            </summary>
        </member>
        <member name="T:DanielWillett.ReflectionTools.StaticFieldVariable`1">
            <summary>
            See <see cref="M:DanielWillett.ReflectionTools.Variables.AsStaticVariable``1(System.Reflection.FieldInfo,DanielWillett.ReflectionTools.IAccessor)"/>.
            </summary>
        </member>
        <member name="T:DanielWillett.ReflectionTools.FieldVariable">
            <summary>
            See <see cref="M:DanielWillett.ReflectionTools.Variables.AsVariable(System.Reflection.FieldInfo,DanielWillett.ReflectionTools.IAccessor)"/>.
            </summary>
        </member>
        <member name="T:DanielWillett.ReflectionTools.IInstanceVariable`2">
            <summary>
            Strongly-typed abstraction for instance <see cref="T:System.Reflection.FieldInfo"/> and <see cref="T:System.Reflection.PropertyInfo"/>.
            </summary>
            <remarks>See the <see cref="T:DanielWillett.ReflectionTools.Variables"/> class for creation and utility methods.</remarks>
            <typeparam name="TMemberType">The returning type of the member.</typeparam>
            <typeparam name="TDeclaringType">The type in which this variable is defined in.</typeparam>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IInstanceVariable`2.GenerateGetter(System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate if possible, otherwise a dynamic method, that gets a property or field value. Works for reference or value types.
            </summary>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).
            This also must be <see langword="true"/> to not null-check instance methods of parameter-less reference types with a dynamic method.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
            <exception cref="T:System.InvalidOperationException">This member does not implement 'get' functionality when <paramref name="throwOnError"/> is <see langword="true"/>.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IInstanceVariable`2.GenerateReferenceTypeSetter(System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate if possible, otherwise a dynamic method, that gets a property or field value. For value types use <see cref="M:DanielWillett.ReflectionTools.IInstanceVariable`2.GenerateSetter(System.Boolean,System.Boolean)"/>.
            </summary>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).
            This also must be <see langword="true"/> to not null-check instance methods of parameter-less reference types with a dynamic method.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
            <exception cref="T:System.InvalidOperationException">This member does not implement 'set' functionality when <paramref name="throwOnError"/> is <see langword="true"/>.</exception>
            <exception cref="T:System.ArgumentException"><typeparamref name="TDeclaringType"/> is a value type, in which case <see cref="M:DanielWillett.ReflectionTools.IInstanceVariable`2.GenerateSetter(System.Boolean,System.Boolean)"/> should be used.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IInstanceVariable`2.GenerateSetter(System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate if possible, otherwise a dynamic method, that sets an instance property value.
            When using value types, you have to store the value type in a boxed variable before passing it. This allows you to pass it as a reference type.<br/><br/>
            <code>
            object instance = new CustomStruct();
            SetProperty.Invoke(instance, 3);
            CustomStruct result = (CustomStruct)instance;
            </code>
            </summary>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).
            This also must be <see langword="true"/> to not null-check instance methods of parameter-less reference types with a dynamic method.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
            <exception cref="T:System.InvalidOperationException">This member does not implement 'set' functionality when <paramref name="throwOnError"/> is <see langword="true"/>.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IInstanceVariable`2.GetValue(`0)">
            <summary>
            Get the value of the field or property with reflection.
            </summary>
            <param name="instance">The instance to get the value from.</param>
            <returns>The value of the variable.</returns>
            <exception cref="T:System.InvalidOperationException">This member does not implement 'get' functionality.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IInstanceVariable`2.SetValue(`0@,`1)">
            <summary>
            Set the value of the field or property with reflection.
            </summary>
            <param name="instance">The instance to get the value from. This is a <see langword="ref"/> parameter to support value types.</param>
            <param name="value">Value to set.</param>
            <returns>The value of the variable.</returns>
            <exception cref="T:System.InvalidOperationException">This member does not implement 'set' functionality.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IInstanceVariable`2.SetValue(`0,`1)">
            <summary>
            Set the value of the field or property with reflection. For value types use <see cref="M:DanielWillett.ReflectionTools.IInstanceVariable`2.SetValue(`0@,`1)"/>.
            </summary>
            <param name="instance">The instance to get the value from.</param>
            <param name="value">Value to set.</param>
            <returns>The value of the variable.</returns>
            <exception cref="T:System.InvalidOperationException">This member does not implement 'set' functionality.</exception>
            <exception cref="T:System.ArgumentException"><typeparamref name="TDeclaringType"/> is a value type, in which case the <see cref="M:DanielWillett.ReflectionTools.IInstanceVariable`2.SetValue(`0@,`1)"/> overload should be used.</exception>
        </member>
        <member name="T:DanielWillett.ReflectionTools.IStaticVariable`1">
            <summary>
            Strongly-typed abstraction for static <see cref="T:System.Reflection.FieldInfo"/> and <see cref="T:System.Reflection.PropertyInfo"/>.
            </summary>
            <remarks>See the <see cref="T:DanielWillett.ReflectionTools.Variables"/> class for creation and utility methods.</remarks>
            <typeparam name="TMemberType">The returning type of the member.</typeparam>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IStaticVariable`1.GenerateGetter(System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate that gets a static property or field value.
            </summary>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).
            This also must be <see langword="true"/> to not null-check instance methods of parameter-less reference types with a dynamic method.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
            <exception cref="T:System.InvalidOperationException">This member does not implement 'get' functionality when <paramref name="throwOnError"/> is <see langword="true"/>.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IStaticVariable`1.GenerateSetter(System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate or dynamic method that sets a static property or field value.
            </summary>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).
            This also must be <see langword="true"/> to not null-check instance methods of parameter-less reference types with a dynamic method.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
            <exception cref="T:System.InvalidOperationException">This member does not implement 'set' functionality when <paramref name="throwOnError"/> is <see langword="true"/>.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IStaticVariable`1.GetValue">
            <summary>
            Get the value of the field or property with reflection.
            </summary>
            <returns>The value of the variable.</returns>
            <exception cref="T:System.InvalidOperationException">This member does not implement 'get' functionality.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IStaticVariable`1.SetValue(`0)">
            <summary>
            Set the value of the field or property with reflection.
            </summary>
            <param name="value">Value to set.</param>
            <returns>The value of the variable.</returns>
            <exception cref="T:System.InvalidOperationException">This member does not implement 'set' functionality.</exception>
        </member>
        <member name="T:DanielWillett.ReflectionTools.IVariable">
            <summary>
            Abstraction for <see cref="T:System.Reflection.FieldInfo"/> and <see cref="T:System.Reflection.PropertyInfo"/>.
            </summary>
            <remarks>See the <see cref="T:DanielWillett.ReflectionTools.Variables"/> class for creation and utility methods.</remarks>
        </member>
        <member name="P:DanielWillett.ReflectionTools.IVariable.CanGet">
            <summary>
            If it is safe to get the value.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.IVariable.CanSet">
            <summary>
            If it is safe to set the value.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.IVariable.IsStatic">
            <summary>
            If <see cref="P:DanielWillett.ReflectionTools.IVariable.Member"/> is <see langword="static"/>.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.IVariable.IsProperty">
            <summary>
            If this variable is a <see cref="T:System.Reflection.PropertyInfo"/>.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.IVariable.IsField">
            <summary>
            If this variable is a <see cref="T:System.Reflection.FieldInfo"/>.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.IVariable.DeclaringType">
            <summary>
            The type <see cref="P:DanielWillett.ReflectionTools.IVariable.Member"/> is declared in.
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.IVariable.MemberType">
            <summary>
            The type <see cref="P:DanielWillett.ReflectionTools.IVariable.Member"/> returns (field or property type).
            </summary>
        </member>
        <member name="P:DanielWillett.ReflectionTools.IVariable.Member">
            <summary>
            Backing member, either a <see cref="T:System.Reflection.FieldInfo"/> or <see cref="T:System.Reflection.PropertyInfo"/>.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IVariable.GetValue(System.Object)">
            <summary>
            Get the value of the field or property with reflection.
            </summary>
            <param name="instance">The instance to get the value from. Pass <see langword="null"/> for static variables.</param>
            <returns>The value of the variable.</returns>
            <exception cref="T:System.InvalidOperationException">This member does not implement 'get' functionality.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IVariable.SetValue(System.Object,System.Object)">
            <summary>
            Set the value of the field or property with reflection.
            </summary>
            <param name="instance">The instance to get the value from. Pass <see langword="null"/> for static variables.</param>
            <param name="value">Value to set.</param>
            <returns>The value of the variable.</returns>
            <exception cref="T:System.InvalidOperationException">This member does not implement 'set' functionality.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IVariable.Format(System.Boolean,System.Boolean)">
            <summary>
            Format this variable into a string representation using <see cref="P:DanielWillett.ReflectionTools.Accessor.Formatter"/>.
            </summary>
            <param name="includeAccessors">Should the accessors be put at the end.</param>
            <param name="includeDefinitionKeywords">Should definition keywords such as 'readonly', 'public', 'virtual', 'abtract', 'private', etc be included.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IVariable.Format(DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter,System.Boolean,System.Boolean)">
            <summary>
            Format this variable into a string representation.
            </summary>
            <param name="formatter">Implementation of <see cref="T:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter"/> to use.</param>
            <param name="includeAccessors">Should the accessors be put at the end.</param>
            <param name="includeDefinitionKeywords">Should definition keywords such as 'readonly', 'public', 'virtual', 'abtract', 'private', etc be included.</param>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IVariable.GenerateGetter(System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate if possible, otherwise a dynamic method, that gets a property or field value. Works for reference or value types.
            </summary>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).
            This also must be <see langword="true"/> to not null-check instance methods of parameter-less reference types with a dynamic method.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
            <returns>A delegate of type <see cref="T:DanielWillett.ReflectionTools.InstanceGetter`2"/> or <see cref="T:DanielWillett.ReflectionTools.StaticGetter`1"/> depending on if the variable is static or not, with the generic arguments being the same as how they were defined in the field.</returns>
            <exception cref="T:System.InvalidOperationException">This member does not implement 'get' functionality when <paramref name="throwOnError"/> is <see langword="true"/>.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IVariable.GenerateSetter(System.Boolean,System.Boolean)">
            <summary>
            Generates a delegate if possible, otherwise a dynamic method, that sets a property or field value.
            When using value types, you have to store the value type in a boxed variable before passing it. This allows you to pass it as a reference type.<br/><br/>
            <code>
            object instance = new CustomStruct();
            SetProperty.Invoke(instance, 3);
            CustomStruct result = (CustomStruct)instance;
            </code>
            </summary>
            <param name="allowUnsafeTypeBinding">Enables unsafe type binding to non-matching delegates, meaning classes of different
            types can be passed as parameters and an exception will not be thrown (may cause unintended behavior if the wrong type is passed).
            This also must be <see langword="true"/> to not null-check instance methods of parameter-less reference types with a dynamic method.</param>
            <param name="throwOnError">Throw an error instead of writing to console and returning <see langword="null"/>.</param>
            <remarks>Will never return <see langword="null"/> if <paramref name="throwOnError"/> is <see langword="true"/>.</remarks>
            <returns>A delegate of type <see cref="T:DanielWillett.ReflectionTools.InstanceSetter`2"/> or <see cref="T:DanielWillett.ReflectionTools.StaticSetter`1"/> depending on if the variable is static or not, with the generic arguments being the same as how they were defined in the field.</returns>
            <exception cref="T:System.InvalidOperationException">This member does not implement 'set' functionality when <paramref name="throwOnError"/> is <see langword="true"/>.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IVariable.GetFormatLength(System.Boolean,System.Boolean)">
            <summary>
            Calculate the length of the string returned by <see cref="M:DanielWillett.ReflectionTools.IVariable.Format(System.Span{System.Char},System.Boolean,System.Boolean)"/> using <see cref="P:DanielWillett.ReflectionTools.Accessor.Formatter"/>.
            </summary>
            <param name="includeAccessors">Should the accessors be put at the end.</param>
            <param name="includeDefinitionKeywords">Should definition keywords such as 'readonly', 'public', 'virtual', 'abtract', 'private', etc be included.</param>
            <returns>The length in characters of this variable as a string.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IVariable.Format(System.Span{System.Char},System.Boolean,System.Boolean)">
            <summary>
            Format this variable into a string representation using <see cref="P:DanielWillett.ReflectionTools.Accessor.Formatter"/>. Use <see cref="M:DanielWillett.ReflectionTools.IVariable.GetFormatLength(System.Boolean,System.Boolean)"/> to get the desired length of <paramref name="output"/>.
            </summary>
            <param name="output">Buffer to put the formatted characters in.</param>
            <param name="includeAccessors">Should the accessors be put at the end.</param>
            <param name="includeDefinitionKeywords">Should definition keywords such as 'readonly', 'public', 'virtual', 'abtract', 'private', etc be included.</param>
            <returns>The length in characters of this variable as a string that were written to <paramref name="output"/>.</returns>
            <exception cref="T:System.IndexOutOfRangeException"><paramref name="output"/> is not large enough.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IVariable.GetFormatLength(DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter,System.Boolean,System.Boolean)">
            <summary>
            Calculate the length of the string returned by <see cref="M:DanielWillett.ReflectionTools.IVariable.Format(System.Span{System.Char},System.Boolean,System.Boolean)"/>.
            </summary>
            <param name="formatter">Implementation of <see cref="T:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter"/> to use.</param>
            <param name="includeAccessors">Should the accessors be put at the end.</param>
            <param name="includeDefinitionKeywords">Should definition keywords such as 'readonly', 'public', 'virtual', 'abtract', 'private', etc be included.</param>
            <returns>The length in characters of this variable as a string.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.IVariable.Format(DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter,System.Span{System.Char},System.Boolean,System.Boolean)">
            <summary>
            Format this variable into a string representation. Use <see cref="M:DanielWillett.ReflectionTools.IVariable.GetFormatLength(System.Boolean,System.Boolean)"/> to get the desired length of <paramref name="output"/>.
            </summary>
            <param name="formatter">Implementation of <see cref="T:DanielWillett.ReflectionTools.Formatting.IOpCodeFormatter"/> to use.</param>
            <param name="output">Buffer to put the formatted characters in.</param>
            <param name="includeAccessors">Should the accessors be put at the end.</param>
            <param name="includeDefinitionKeywords">Should definition keywords such as 'readonly', 'public', 'virtual', 'abtract', 'private', etc be included.</param>
            <returns>The length in characters of this variable as a string that were written to <paramref name="output"/>.</returns>
            <exception cref="T:System.IndexOutOfRangeException"><paramref name="output"/> is not large enough.</exception>
        </member>
        <member name="T:DanielWillett.ReflectionTools.InstancePropertyVariable`2">
            <summary>
            See <see cref="M:DanielWillett.ReflectionTools.Variables.AsInstanceVariable``2(System.Reflection.PropertyInfo,DanielWillett.ReflectionTools.IAccessor)"/>.
            </summary>
        </member>
        <member name="T:DanielWillett.ReflectionTools.StaticPropertyVariable`1">
            <summary>
            See <see cref="M:DanielWillett.ReflectionTools.Variables.AsStaticVariable``1(System.Reflection.PropertyInfo,DanielWillett.ReflectionTools.IAccessor)"/>.
            </summary>
        </member>
        <member name="T:DanielWillett.ReflectionTools.PropertyVariable">
            <summary>
            <see cref="T:DanielWillett.ReflectionTools.Variables"/>
            </summary>
        </member>
        <member name="T:DanielWillett.ReflectionTools.Variables">
            <summary>
            Class for creating and extending <see cref="T:DanielWillett.ReflectionTools.IVariable"/>, which bridges the gap between fields and properties.
            </summary>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Variables.AsVariable(System.Reflection.FieldInfo,DanielWillett.ReflectionTools.IAccessor)">
            <summary>
            Creates an abstracted <see cref="T:DanielWillett.ReflectionTools.IVariable"/> for <paramref name="field"/>.
            </summary>
            <param name="field">The underlying field.</param>
            <param name="accessor"><see cref="T:DanielWillett.ReflectionTools.IAccessor"/> instance to use for accessors. Defaults to <see cref="P:DanielWillett.ReflectionTools.Accessor.Active"/>.</param>
            <returns>An abstracted variable with <paramref name="field"/> as it's underlying field.</returns>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Variables.AsVariable(System.Reflection.PropertyInfo,DanielWillett.ReflectionTools.IAccessor)">
            <summary>
            Creates an abstracted <see cref="T:DanielWillett.ReflectionTools.IVariable"/> for <paramref name="property"/>.
            </summary>
            <param name="property">The underlying property.</param>
            <param name="accessor"><see cref="T:DanielWillett.ReflectionTools.IAccessor"/> instance to use for accessors. Defaults to <see cref="P:DanielWillett.ReflectionTools.Accessor.Active"/>.</param>
            <returns>An abstracted variable with <paramref name="property"/> as it's underlying property.</returns>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Variables.AsVariable(System.Reflection.MemberInfo,DanielWillett.ReflectionTools.IAccessor)">
            <summary>
            Creates an abstracted <see cref="T:DanielWillett.ReflectionTools.IVariable"/> for <paramref name="member"/>, a field or property.
            </summary>
            <param name="member">The underlying field or property. Must be of type <see cref="T:System.Reflection.FieldInfo"/> or <see cref="T:System.Reflection.PropertyInfo"/>.</param>
            <param name="accessor"><see cref="T:DanielWillett.ReflectionTools.IAccessor"/> instance to use for accessors. Defaults to <see cref="P:DanielWillett.ReflectionTools.Accessor.Active"/>.</param>
            <returns>An abstracted variable with <paramref name="member"/> as it's underlying field or property.</returns>
            <exception cref="T:System.ArgumentNullException"/>
            <exception cref="T:System.ArgumentException"><paramref name="member"/> is not a field or property.</exception>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Variables.AsStaticVariable``1(System.Reflection.FieldInfo,DanielWillett.ReflectionTools.IAccessor)">
            <summary>
            Creates a static, strongly-typed, abstracted <see cref="T:DanielWillett.ReflectionTools.IVariable"/> for <paramref name="field"/>.
            </summary>
            <param name="field">The underlying field.</param>
            <param name="accessor"><see cref="T:DanielWillett.ReflectionTools.IAccessor"/> instance to use for accessors. Defaults to <see cref="P:DanielWillett.ReflectionTools.Accessor.Active"/>.</param>
            <typeparam name="TMemberType">The field type of <paramref name="field"/>.</typeparam>
            <returns>An abstracted variable with <paramref name="field"/> as it's underlying field.</returns>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Variables.AsStaticVariable``1(System.Reflection.PropertyInfo,DanielWillett.ReflectionTools.IAccessor)">
            <summary>
            Creates a static, strongly-typed, abstracted <see cref="T:DanielWillett.ReflectionTools.IVariable"/> for <paramref name="property"/>.
            </summary>
            <param name="property">The underlying property.</param>
            <param name="accessor"><see cref="T:DanielWillett.ReflectionTools.IAccessor"/> instance to use for accessors. Defaults to <see cref="P:DanielWillett.ReflectionTools.Accessor.Active"/>.</param>
            <typeparam name="TMemberType">The property type of <paramref name="property"/>.</typeparam>
            <returns>An abstracted variable with <paramref name="property"/> as it's underlying property.</returns>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Variables.AsInstanceVariable``2(System.Reflection.FieldInfo,DanielWillett.ReflectionTools.IAccessor)">
            <summary>
            Creates an instance, strongly-typed, abstracted <see cref="T:DanielWillett.ReflectionTools.IVariable"/> for <paramref name="field"/>.
            </summary>
            <param name="field">The underlying field.</param>
            <param name="accessor"><see cref="T:DanielWillett.ReflectionTools.IAccessor"/> instance to use for accessors. Defaults to <see cref="P:DanielWillett.ReflectionTools.Accessor.Active"/>.</param>
            <typeparam name="TMemberType">The field type of <paramref name="field"/>.</typeparam>
            <typeparam name="TDeclaringType">The type that <paramref name="field"/> is declared in.</typeparam>
            <returns>An abstracted variable with <paramref name="field"/> as it's underlying field.</returns>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Variables.AsInstanceVariable``2(System.Reflection.PropertyInfo,DanielWillett.ReflectionTools.IAccessor)">
            <summary>
            Creates an instance, strongly-typed, abstracted <see cref="T:DanielWillett.ReflectionTools.IVariable"/> for <paramref name="property"/>.
            </summary>
            <param name="property">The underlying property.</param>
            <param name="accessor"><see cref="T:DanielWillett.ReflectionTools.IAccessor"/> instance to use for accessors. Defaults to <see cref="P:DanielWillett.ReflectionTools.Accessor.Active"/>.</param>
            <typeparam name="TMemberType">The property type of <paramref name="property"/>.</typeparam>
            <typeparam name="TDeclaringType">The type that <paramref name="property"/> is declared in.</typeparam>
            <returns>An abstracted variable with <paramref name="property"/> as it's underlying property.</returns>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Variables.TryFind``1(System.String,DanielWillett.ReflectionTools.IVariable@,System.Boolean,DanielWillett.ReflectionTools.IAccessor)">
            <summary>
            Find a variable by declaring type and name.
            </summary>
            <param name="name">Exact name of the field or property.</param>
            <param name="ignoreCase">Whether or not to perform a case-insensitive search.</param>
            <param name="variable">The found variable, or <see langword="null"/>.</param>
            <param name="accessor"><see cref="T:DanielWillett.ReflectionTools.IAccessor"/> instance to use for accessors. Defaults to <see cref="P:DanielWillett.ReflectionTools.Accessor.Active"/>.</param>
            <typeparam name="TDeclaringType">Type which declares the member, or a type up the hierarchy of a type that declares the member.</typeparam>
            <returns><see langword="true"/> if the variable was found, otherwise <see langword="false"/>.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Variables.TryFind(System.Type,System.String,DanielWillett.ReflectionTools.IVariable@,System.Boolean,DanielWillett.ReflectionTools.IAccessor)">
            <summary>
            Find a variable by declaring type and name.
            </summary>
            <param name="declaringType">Type which declares the member, or a type up the hierarchy of a type that declares the member.</param>
            <param name="name">Exact name of the field or property.</param>
            <param name="variable">The found variable, or <see langword="null"/>.</param>
            <param name="ignoreCase">Whether or not to perform a case-insensitive search.</param>
            <param name="accessor"><see cref="T:DanielWillett.ReflectionTools.IAccessor"/> instance to use for accessors. Defaults to <see cref="P:DanielWillett.ReflectionTools.Accessor.Active"/>.</param>
            <returns><see langword="true"/> if the variable was found, otherwise <see langword="false"/>.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Variables.TryFindStatic``2(System.String,DanielWillett.ReflectionTools.IStaticVariable{``1}@,System.Boolean,DanielWillett.ReflectionTools.IAccessor)">
            <summary>
            Find a variable by declaring type and name.
            </summary>
            <param name="name">Exact name of the field or property.</param>
            <param name="ignoreCase">Whether or not to perform a case-insensitive search.</param>
            <param name="variable">The found variable, or <see langword="null"/>.</param>
            <param name="accessor"><see cref="T:DanielWillett.ReflectionTools.IAccessor"/> instance to use for accessors. Defaults to <see cref="P:DanielWillett.ReflectionTools.Accessor.Active"/>.</param>
            <typeparam name="TMemberType">The type of the field or property.</typeparam>
            <typeparam name="TDeclaringType">Type which declares the member, or a type up the hierarchy of a type that declares the member.</typeparam>
            <returns><see langword="true"/> if the variable was found, otherwise <see langword="false"/>.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Variables.TryFindStatic``1(System.Type,System.String,DanielWillett.ReflectionTools.IStaticVariable{``0}@,System.Boolean,DanielWillett.ReflectionTools.IAccessor)">
            <summary>
            Find a variable by declaring type and name.
            </summary>
            <param name="name">Exact name of the field or property.</param>
            <param name="ignoreCase">Whether or not to perform a case-insensitive search.</param>
            <param name="variable">The found variable, or <see langword="null"/>.</param>
            <param name="declaringType">Type which declares the member, or a type up the hierarchy of a type that declares the member.</param>
            <param name="accessor"><see cref="T:DanielWillett.ReflectionTools.IAccessor"/> instance to use for accessors. Defaults to <see cref="P:DanielWillett.ReflectionTools.Accessor.Active"/>.</param>
            <typeparam name="TMemberType">The type of the field or property.</typeparam>
            <returns><see langword="true"/> if the variable was found, otherwise <see langword="false"/>.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Variables.Find``1(System.String,System.Boolean,DanielWillett.ReflectionTools.IAccessor)">
            <summary>
            Find a variable by declaring type and name.
            </summary>
            <param name="name">Exact name of the field or property.</param>
            <param name="ignoreCase">Whether or not to perform a case-insensitive search.</param>
            <param name="accessor"><see cref="T:DanielWillett.ReflectionTools.IAccessor"/> instance to use for accessors. Defaults to <see cref="P:DanielWillett.ReflectionTools.Accessor.Active"/>.</param>
            <typeparam name="TDeclaringType">Type which declares the member, or a type up the hierarchy of a type that declares the member.</typeparam>
            <returns>The found variable, or <see langword="null"/>.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Variables.FindStatic``2(System.String,System.Boolean,DanielWillett.ReflectionTools.IAccessor)">
            <summary>
            Find a variable by declaring type and name.
            </summary>
            <param name="name">Exact name of the field or property.</param>
            <param name="ignoreCase">Whether or not to perform a case-insensitive search.</param>
            <param name="accessor"><see cref="T:DanielWillett.ReflectionTools.IAccessor"/> instance to use for accessors. Defaults to <see cref="P:DanielWillett.ReflectionTools.Accessor.Active"/>.</param>
            <typeparam name="TDeclaringType">Type which declares the member, or a type up the hierarchy of a type that declares the member.</typeparam>
            <typeparam name="TMemberType">The type of the field or property.</typeparam>
            <returns>The found variable, or <see langword="null"/>.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Variables.Find(System.Type,System.String,System.Boolean,DanielWillett.ReflectionTools.IAccessor)">
            <summary>
            Find a variable by declaring type and name.
            </summary>
            <param name="declaringType">Type which declares the member, or a type up the hierarchy of a type that declares the member.</param>
            <param name="name">Exact name of the field or property.</param>
            <param name="ignoreCase">Whether or not to perform a case-insensitive search.</param>
            <param name="accessor"><see cref="T:DanielWillett.ReflectionTools.IAccessor"/> instance to use for accessors. Defaults to <see cref="P:DanielWillett.ReflectionTools.Accessor.Active"/>.</param>
            <returns>The found variable, or <see langword="null"/>.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Variables.FindStatic``1(System.Type,System.String,System.Boolean,DanielWillett.ReflectionTools.IAccessor)">
            <summary>
            Find a static variable by declaring type and name.
            </summary>
            <typeparam name="TMemberType">The type of the field or property.</typeparam>
            <param name="declaringType">Type which declares the member, or a type up the hierarchy of a type that declares the member.</param>
            <param name="name">Exact name of the field or property.</param>
            <param name="ignoreCase">Whether or not to perform a case-insensitive search.</param>
            <param name="accessor"><see cref="T:DanielWillett.ReflectionTools.IAccessor"/> instance to use for accessors. Defaults to <see cref="P:DanielWillett.ReflectionTools.Accessor.Active"/>.</param>
            <returns>The found variable, or <see langword="null"/>.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Variables.FindInstance``2(System.String,System.Boolean,DanielWillett.ReflectionTools.IAccessor)">
            <summary>
            Find an instance variable by declaring type and name.
            </summary>
            <typeparam name="TMemberType">The type of the field or property.</typeparam>
            <typeparam name="TDeclaringType">Type which declares the member, or a type up the hierarchy of a type that declares the member.</typeparam>
            <param name="name">Exact name of the field or property.</param>
            <param name="ignoreCase">Whether or not to perform a case-insensitive search.</param>
            <param name="accessor"><see cref="T:DanielWillett.ReflectionTools.IAccessor"/> instance to use for accessors. Defaults to <see cref="P:DanielWillett.ReflectionTools.Accessor.Active"/>.</param>
            <returns>The found variable, or <see langword="null"/>.</returns>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Variables.IsAssignableFrom(DanielWillett.ReflectionTools.IVariable,System.Type)">
            <summary>
            Checks if it is safe to set this variable to a value of <paramref name="type"/>.
            </summary>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Variables.IsAssignableFrom``1(DanielWillett.ReflectionTools.IVariable)">
            <summary>
            Checks if it is safe to set this variable to a value of <typeparamref name="T"/>.
            </summary>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Variables.IsAssignableTo(DanielWillett.ReflectionTools.IVariable,System.Type)">
            <summary>
            Checks if it is safe to get a variable and cast the result to <paramref name="type"/>.
            </summary>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Variables.IsAssignableTo``1(DanielWillett.ReflectionTools.IVariable)">
            <summary>
            Checks if it is safe to get a variable and cast the result to <typeparamref name="T"/>.
            </summary>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Variables.CouldBeAssignedTo(DanielWillett.ReflectionTools.IVariable,System.Type)">
            <summary>
            Checks if it's possible for <paramref name="variable"/> to have a value of type <paramref name="type"/>. 
            </summary>
            <returns><see langword="true"/> if the type of <paramref name="variable"/> is assignable from <paramref name="type"/> or if <paramref name="type"/> is assignable from the type of <paramref name="variable"/>.</returns>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanielWillett.ReflectionTools.Variables.CouldBeAssignedTo``1(DanielWillett.ReflectionTools.IVariable)">
            <summary>
            Checks if it's possible for a variable of type <paramref name="variable"/> to have a value of type <typeparamref name="T"/>. 
            </summary>
            <returns><see langword="true"/> if the type of <paramref name="variable"/> is assignable from <typeparamref name="T"/> or if <typeparamref name="T"/> is assignable from the type of <paramref name="variable"/>.</returns>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
    </members>
</doc>
